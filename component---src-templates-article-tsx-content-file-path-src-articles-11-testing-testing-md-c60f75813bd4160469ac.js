"use strict";(self.webpackChunkhomepage=self.webpackChunkhomepage||[]).push([[597],{9077:function(e,t,n){n.r(t),n.d(t,{Head:function(){return x},default:function(){return S}});var a=n(8453),l=n(6540);function r(e){const t=Object.assign({p:"p",a:"a",h1:"h1",span:"span",pre:"pre",code:"code",ul:"ul",li:"li"},(0,a.R)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.p,null,"Writing tests is awful!\nWhen I program I often think,\n\"I don't need tests.\nTests are for broken code only.\n",l.createElement(t.a,{href:"https://www.youtube.com/watch?v=5TTcbMv5tDc&t=144s"},"I'm built different")," — my code isn't broken.\""),"\n",l.createElement(t.p,null,"And then I spend an hour in gdb..."),"\n",l.createElement(t.h1,{id:"invariants",style:{position:"relative"}},l.createElement(t.a,{href:"#invariants","aria-label":"invariants permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Invariants"),"\n",l.createElement(t.p,null,"Take a look at this C code."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-c"},'size_t last_size = 1;\nfor(size_t i = 0; i < num_allocators; ++i) {\n    // this crashes the program when the condition is not met\n    ASSERT(allocators[i].size >= last_size,\n           "allocators must be ordered by size");\n    last_size = allocators[i].size;\n}\n')),"\n",l.createElement(t.p,null,"It asserts an invariant of a toy allocator I wrote.\nMore specifically it asserts that the ",l.createElement(t.code,null,"allocators")," list is ordered by the ",l.createElement(t.code,null,"size")," attribute — that's the invariant that must hold.\nThis code is very quick to write and easy to manually verify."),"\n",l.createElement(t.p,null,"All the places that touch the ",l.createElement(t.code,null,"allocators")," list, on the other hand, are quite complex and potentially break the invariant.\nVerifying those is way more difficult.\nAnd when there is a mistake in one of these places this bug will likely be visible as a crash or wrong output.\nFiguring out that this bug has something to do with ",l.createElement(t.code,null,"allocators"),"' order takes a lot of time.\nAnd I often spend that time writing debugging or ",l.createElement(t.code,null,"printf")," statements.\nThose statements could have been asserts in the first place!"),"\n",l.createElement(t.p,null,"What's more, asserting invariants declares intent:\nReading through all the actual code is a lot easier when you already know that ",l.createElement(t.code,null,"allocators")," is sorted.\nAdditionally, you can mark special sections where this invariant is allowed to not hold by commenting why you don't check it."),"\n",l.createElement(t.h1,{id:"example-usage",style:{position:"relative"}},l.createElement(t.a,{href:"#example-usage","aria-label":"example usage permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example Usage"),"\n",l.createElement(t.p,null,"Here's another one:\nSometimes I know some example input/output-pair for a function before actually implementing the function.\nSo I just write down all the example pairs I can think of and get some tests for cheap!"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-c"},"ASSERT(alloc_idx_to_size(0) == 8);\nASSERT(alloc_idx_to_size(1) == 16);\nASSERT(alloc_idx_to_size(2) == 32);\nASSERT(alloc_idx_to_size(3) == 64);\nASSERT(alloc_idx_to_size(4) == 128);\nASSERT(alloc_idx_to_size(5) == 256);\nASSERT(alloc_idx_to_size(6) == 512);\nASSERT(alloc_idx_to_size(7) == 1024);\n")),"\n",l.createElement(t.h1,{id:"in-code",style:{position:"relative"}},l.createElement(t.a,{href:"#in-code","aria-label":"in code permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"In Code"),"\n",l.createElement(t.p,null,"Here there are two ways of finding the allocator I'm looking for:\nA binary search with ",l.createElement(t.code,null,"find_alloc_binary_search")," and a linear search by checking ",l.createElement(t.code,null,"is_object_in_alloc")," for all ",l.createElement(t.code,null,"allocators"),".\nI ended up performing the faster but more complicated binary search and then asserting what I did with ",l.createElement(t.code,null,"is_object_in_alloc"),"."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-c"},'struct balloc* alloc = find_alloc_binary_search(memory);\nASSERT(is_object_in_alloc(alloc, memory),\n       "found allocator must contain memory");\n')),"\n",l.createElement(t.p,null,"When I have three ways of implementing something I implement it one way and use the other two to assert I did so correctly.\nEvery different implementation is another perspective on the problem.\nUsing more than one perspective makes sure you actually understand your problem."),"\n",l.createElement(t.p,null,"I write these asserts not to create a higher quality product.\nI use other things for that: exhaustive unit tests, stress tests, end-to-end tests, user tests, contracts, ...\nAnd sometimes I don't care about quality and I just want my script to not crash.\nIn all cases these asserts and invariants I talked about make sense.\nThey are only for getting the job done more quickly."),"\n",l.createElement(t.p,null,"As such, every assert I write helps.\nWhen you're aiming for quality your tests need to be somewhat exhaustive and actually ensure they catch everything that's wrong.\nWhen you're aiming for a speed-up they only need to help pinpoint the origin of something going wrong.\nI invite you to try this way of looking at writing tests — it's fun!"),"\n",l.createElement(t.p,null,"Btw, you can write these tests in whatever language, whatever framework and for whatever project:\nIn C I like asserting I'm not holding a ",l.createElement(t.code,null,"nullptr")," when I don't believe it to and in Python/numpy I check my ",l.createElement(t.a,{href:"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html"},"ndarray")," has the shape I expect it to.\nOh, and when you configure them to be stripped from the final release build and you don't loose any performance, too."),"\n",l.createElement(t.h1,{id:"concluding",style:{position:"relative"}},l.createElement(t.a,{href:"#concluding","aria-label":"concluding permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Concluding"),"\n",l.createElement(t.p,null,"These sorts of tests are"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"easy to create,"),"\n",l.createElement(t.li,null,"save a bunch of time,"),"\n",l.createElement(t.li,null,"declare intent and"),"\n",l.createElement(t.li,null,"don't have to be exhaustive — just write down whatever pops into your head."),"\n"),"\n",l.createElement(t.p,null,"With all these asserts my commit history looks like this:\nOne feature, then a bunch of fixes until all my asserts are happy."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"feat: implement alloc and dealloc - christopher-besch\nfix:  these asserts do find bugs - christopher-besch\nfix:  use index instead of pointer to same size alloc; fixes issue when moving allocs - christopher-besch\nfix:  lower_bound assert - christopher-besch\nfix:  keep alloc_idx as before as it should - christopher-besch\nfix:  >= in is_object_after_alloc - christopher-besch\nfix:  handle nullptr in dealloc gracefully - christopher-besch\nfix:  alloc with size 0 - christopher-besch\nfix:  forgot to multiply with BLOCKS_PER_SLAB - christopher-besch\n")),"\n",l.createElement(t.p,null,"Without my asserts I would have found these bugs much later and wouldn't have had as much fun getting rid of them."),"\n",l.createElement(t.h1,{id:"ps",style:{position:"relative"}},l.createElement(t.a,{href:"#ps","aria-label":"ps permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"PS"),"\n",l.createElement(t.p,null,"All the code in this article has been heavily abbreviated and was part of an assignment to write fast but correct code.\nI really tried to maximize my use of asserts and ended up with every fifth line being an assert.\nWas my code particularly fast in the end?\nKinda, but it wasn't the fastest.\nWas it still fun, yeah!\nAnd that's what matters to me."),"\n",l.createElement(t.h1,{id:"pps",style:{position:"relative"}},l.createElement(t.a,{href:"#pps","aria-label":"pps permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"PPS"),"\n",l.createElement(t.p,null,"Yes, my commit messages could use some work but committing as often as possible is more important, I think."))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.R)(),e.components);return t?l.createElement(t,e,l.createElement(r,e)):r(e)},i=n(5365),s=n(2224),c=n(9121),h=n(4241),d=n(4810),m=n(1244),u=n(5071),p=n(9105),f=n(6897),v=n(7629),g=n(8029),y=n(1042),b=n(5526),E=n(5969);const _={AutoPlayVideo:u.A,HalfImage:p.A,Spacer:f.A,Quote:v.A,Iframe:g.A,CompareView:m.A,pre:e=>{let{children:t}=e;return l.createElement("div",{className:"code-container"}," ",l.createElement("pre",null,t))},code:e=>{let{children:t,className:n}=e;return n?l.createElement(b.A,{className:n},t):l.createElement("code",{className:"language-text"},t)},a:E.A},w=e=>{var t,n,r,o,m,u,p,f,v,g,y,b,E,w;let{data:S,children:x}=e;const I=null===(t=S.mdx)||void 0===t||null===(n=t.frontmatter)||void 0===n?void 0:n.version,k=null===(r=S.mdx)||void 0===r||null===(o=r.frontmatter)||void 0===o?void 0:o.title,z=/^0\./.test(I)?`Draft v${I}`:void 0,A=null===(m=S.mdx)||void 0===m||null===(u=m.frontmatter)||void 0===u?void 0:u.date,H=null!=(null===(p=S.mdx)||void 0===p||null===(f=p.frontmatter)||void 0===f?void 0:f.title_banner),T={"--banner-image-horizontal-position":null===(v=S.mdx)||void 0===v||null===(g=v.frontmatter)||void 0===g?void 0:g.title_banner_horizontal_position,"--banner-image-vertical-position":null===(y=S.mdx)||void 0===y||null===(b=y.frontmatter)||void 0===b?void 0:b.title_banner_vertical_position};return l.createElement(i.A,{heading:k,sub_heading:z,banner_image:H?null===(E=S.mdx)||void 0===E||null===(w=E.frontmatter)||void 0===w?void 0:w.title_banner:void 0,banner_image_style:T,small_banner:!0,banner_content:l.createElement("div",{className:`${s.yu} ${H?s.Lx:void 0}`},l.createElement("span",{className:s.cy},"Written by Christopher Besch, published on "),A)},l.createElement("div",{className:c.xo},l.createElement(a.x,{components:_},x)),l.createElement(d.N_,{className:`${h.om} ${h.nf}`,to:"/articles"},"More Articles"))};function S(e){return l.createElement(w,e,l.createElement(o,e))}const x=e=>{var t,n,a,r,o,i;let{data:s}=e;const c=null===(t=s.mdx)||void 0===t||null===(n=t.frontmatter)||void 0===n?void 0:n.title,h=null===(a=s.mdx)||void 0===a||null===(r=a.frontmatter)||void 0===r?void 0:r.description,d=null===(o=s.mdx)||void 0===o||null===(i=o.frontmatter)||void 0===i?void 0:i.banner,m=d&&"undefined"!=d?d:void 0;return l.createElement(y.A,{heading:c,description:h,banner:m})}}}]);
//# sourceMappingURL=component---src-templates-article-tsx-content-file-path-src-articles-11-testing-testing-md-c60f75813bd4160469ac.js.map