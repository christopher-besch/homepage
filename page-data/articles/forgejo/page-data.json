{"componentChunkName":"component---src-templates-article-tsx-content-file-path-src-articles-17-forgejo-fogejo-md","path":"/articles/forgejo/","result":{"data":{"mdx":{"body":"\nForgejo is a code forge:\nJust like GitHub or GitLab it's a place to (collaboratively) develop software.\nBecause Forgejo is incredibly easy to self-host and I love it's Open-Source community, I chose it for my private code forge.\nI've already explained at length [why I love Open-Source](/articles/open_source) so much.\n\nWith my new code forge up and running there were a few features my team needed.\nSpecifically we needed to receive email notifications and webhooks when a CI Workflow failed.\nForgejo didn't offer that feature so I started contributing to Forgejo.\nThrough this article I want to give back as much of what I've learned in doing so.\nThe parts that took the most effort where\n- setting up a development environment,\n- understanding Forgejo's notification architecture,\n- actually implementing the features and\n- writing exhaustive tests for the features I implemented.\n\nBe aware that I'm describing all of this as of commit `b2c4fc9f94` (Sat Jun 21 13:11:01 2025 +0200).\nSome of this information may be outdated for any newer state of the code base.\n\n## Development Setup\nTo test the features I developed I don't just need the Forgjeo executable.\nNo, I also need an action runner, a mail server and some place to send webhooks to.\nLet's start with just getting a Forgejo test instance up and running.\n1. I use Debian but this setup should work on all Linux distros (and maybe macOS and BSD?).\n2. [Install node and npm](https://github.com/nvm-sh/nvm?tab=readme-ov-file#install--update-script).\n3. [Install go](https://go.dev/doc/install).\n4. Install [gotestsum](https://github.com/gotestyourself/gotestsum).\n   This is entirely optional.\n   If you don't install gotestsum, ignore all the `USE_GOTESTSUM=yes` statements below.\n5. Download the [Forgejo Repo](https://codeberg.org/forgejo/forgejo) with `git clone https://codeberg.org/forgejo/forgejo ~/forgejo && cd ~/forgejo`.\n6. Build an executable with `STRIP=\"0\" EXTRA_GOFLAGS='-gcflags=\"all=-N -l\"' TAGS=\"sqlite sqlite_unlock_notify\" make build`.\n   It took me a while to realize that `go build` enables optimization by default but keeps all debug symbols present.\n   We change that with the `gsflags` by neither optimizing or inlining.\n   Furthermore, Forgejo's Makefile strips the debug symbols so we disable that with the `STRIP` environment variable.\n7. Run `./gitea`.\n   Yes, the executable is still called that.\n8. Open a webbrowser and navigate to [http://localhost:3000](http://localhost:3000).\n9. Choose SQLite, create an admin account and keep everything else default.\n   Your config is in `~/forgejo/custom/conf/app.ini`.\n10. Create the `test_repo` repository and add the file `.forgejo/workflows/main.yml`:\n    ```yaml\n    enable-email-notifications: true\n    on:\n      workflow_dispatch:\n    \n    jobs:\n      test:\n        runs-on: self-hosted\n        steps:\n          - name: Echo\n            run: |\n              echo Hello World!\n          - name: Fail\n            run: |\n              false\n    ```\n    You can make your life a little easier by cloning the repo: `git clone http://localhost:3000/chris_admin/test_repo.git ~forgejo_test_repo`.\n    You'll have to follow the prompts and configure your `user.email` and `user.name`.\n    I'm using password login, btw.\n11. Download the [Forgejo runner binary](https://code.forgejo.org/forgejo/runner/releases) into `~/forgejo_runner`.\n12. Register the runner with `./forgejo-runner-11.1.2-linux-amd64 register`, give the instance URL `http://localhost:3000`, the runner token you get from the repo settings in the web interface, choose a name like `test-runner` and select the label `self-hosted:host`.\n13. Run `./forgejo-runner-11.1.2-linux-amd64 daemon` and click the workflow trigger button in the web interface.\n    You should see your workflow run now.\n\nOkay, that works fine but we also want to test sending emails.\nI use [MailDev](https://github.com/maildev/maildev) to create a development email server.\nIt provides an SMTP server, which Forgejo connects to, and a webinterface for me, the developer.\n1. [Install Docker](https://docs.docker.com/engine/install).\n2. Run `docker run --network host -p 1080:1080 -p 1025:1025 maildev/maildev`.\n3. Open [http://localhost:1080](http://localhost:1080) in a webbrowser.\n4. Shutdown Forgejo and edit it's config (in `~/forgejo/custom/conf/app.ini`).\n   ```\n   [mailer]\n   ENABLED = true\n   PROTOCOL = smtp\n   SMTP_ADDR = localhost\n   SMTP_PORT = 1025\n   FROM = forgejo@localhost\n\n   # make sure this is true\n   [service]\n   ENABLE_NOTIFY_MAIL = true\n   ```\n5. Now, when the workflow fails you should get a mail in the MailDev web interface.\n\nFurthermore, we want to test webhooks.\n1. I'm using [this node script](https://stackoverflow.com/a/46787467) as a test webhook:\n   `webhook_tester.js`:\n   ```js\n   #!/usr/bin/env node\n\n   const http = require(\"http\");\n\n   const hostname = \"0.0.0.0\";\n   const port = 8001;\n\n   const server = http.createServer((req, res) => {\n     console.log(`\\n${req.method} ${req.url}`);\n     console.log(req.headers);\n\n     req.on(\"data\", function(chunk) {\n       console.log(\"BODY: \" + chunk);\n     });\n\n     res.statusCode = 200;\n     res.setHeader(\"Content-Type\", \"text/plain\");\n     res.end(\"Hello World\\n\");\n   });\n\n   server.listen(port, hostname, () => {\n     console.log(`Server running at http://localhost:${port}/`);\n   });\n   ```\n2. Run `./webhook_tester.js`.\n3. Shutdown Forgejo and edit it's config (in `~/forgejo/custom/conf/app.ini`).\n   For Forgejo to accept `http://localhost:8001` as a webhook target you need to add this:\n   ```ini\n   [webhook]\n   ALLOWED_HOST_LIST = *\n   SKIP_TLS_VERIFY = true\n   ```\n4. Create a new webhook in the Repo Settings and use the target URL `http://localhost:8001`.\n   Enable either *All events* or *Custom events*, selecting the *Action Run events*.\n5. Start the workflow, let it fail and watch the sent webhook in the node terminal.\n\n### Running All Tests\nForejeo has are different types of tests.\nI was concerned with these types.\n- Run all unit tests with `TAGS='sqlite sqlite_unlock_notify' USE_GOTESTSUM=yes make test`.\n- Run all integration tests with `TAGS='sqlite sqlite_unlock_notify' USE_GOTESTSUM=yes make test-sqlite`.\n\nThere are other types of tests, namely frontend tests and the End-to-End tests in a special repo.\nI didn't work with these yet so I direct you to the [testing docs](https://forgejo.org/docs/latest/contributor/testing).\n\n### Running Specific Tests\nSay you only want to run this unit test in `~/forgejo/models/actions/run_test.go`:\n```go\nfunc TestGetRunBefore(t *testing.T) {\n  // --snip--\n}\n```\nThen you can execute `USE_GOTESTSUM=yes TAGS='sqlite sqlite_unlock_notify' GO_TEST_PACKAGES='forgejo.org/models/actions' make 'test#TestGetRunBefore'`.\n\nIf you are concerned with this integration test in `~/forgejo/tests/integration/actions_notifications_test.go`:\n```go\nfunc TestActionNotifications(t *testing.T) {\n  // --snip--\n}\n```\nThen you can run `USE_GOTESTSUM=yes TAGS='sqlite sqlite_unlock_notify' make 'test-sqlite#TestActionNotifications'`.\n\n### Debugging Tests\nTODO\n`break forgejo.org/tests/integration.TestActionNotification`\n\n### Debugging\nI like the terminal and am used to GDB.\nTherefore I'm using the terminal debugger [Delve](https://github.com/go-delve/delve).\nLet's set things up for that:\n1. [Install Delve](https://github.com/go-delve/delve/tree/master/Documentation/installation).\n2. Build Forgejo as described [above](#development-setup).\n3. Run `dlv exec ./gitea`.\n4. Now we can use the Delve console.\n   For example you can do `break forgejo.org/services/mailer.(*mailNotifier).ActionRunNowDone`, `break forgejo.org/services/notify.ActionRunNowDone` and `continue`.\n   Hit `Ctrl+C` to enter a Delve command and type `quit` to exit.\nTODO: debug tests\n\n### Forgejo's Observer Pattern\n- [Forgejo's architecture overview](https://forgejo.org/docs/next/contributor/architecture) is quite helpful.\n- duplicity of structs\n\n## My Changes\n- [#7510: Refactoring](https://codeberg.org/forgejo/forgejo/pulls/7510)\n- [#7491: Actions Done Notification](https://codeberg.org/forgejo/forgejo/pulls/7491)\n- [#7697: After the Fact Cleanup](https://codeberg.org/forgejo/forgejo/pulls/7697)\n- [#7509: Actions Done Mail](https://codeberg.org/forgejo/forgejo/pulls/7509)\n- [#7508: Actions Done Webhook](https://codeberg.org/forgejo/forgejo/pulls/7508)\n- at same time to #7508 [#7699: (not mine) introduce ActionRun, too](https://codeberg.org/forgejo/forgejo/pulls/7508)\n- [#8066: (not mine) rename #7699's struct to RepoActionRun](https://codeberg.org/forgejo/forgejo/pulls/8066)\n- [#8250: (not mine) unify ActionRun and RepoActionRun](https://codeberg.org/forgejo/forgejo/pulls/8250)\n- [#8227: (not mine) Only single user receives mail](https://codeberg.org/forgejo/forgejo/pulls/8227)\n- [#8242: (not mine) actions mail opt-in](https://codeberg.org/forgejo/forgejo/pulls/8242)\n\n## Conclusion and Lessons Learned\n- architecture of Forgejo notifications\n- importance of tests, what tests I wrote\n- testing setup, I didn't have that much time directly after all PRs -> tests vital\n- think of testing not as a side-gig!\n- break things up into multiple PRs\n- less code is better\n- understand as much as possible, then make the minimal change that is needed (knock someone out with your pinky)\n\n# TODO: write\n\nRight now that happens to be Forgejo Action notifications.\nActions are Forgejo's pendant to GitHub Actions.\nThey are used to build and test code in a **c**ontinuous **i**ntegration/**d**eployment (CI/CD) pipeline.\nNow something Forgejo lacked was a notification when something went wrong\n\nSo, I had a stab at understanding Forgejo's code and from what I can tell this is how a webhook gets turned into an actual http request:\n\n- services/webhook/deliver.go.Deliver() called by\n- services/webhook/webhook.go.handler() used as handler in hookQueue in\n- services/webhook/deliver.go.Init()\n- the hookQueue is filled in services/webhook/webhook.go.enqueueHookTask() called in\n- services/webhook/webhook.go.PrepareWebhook() called in\n- services/webhook/webhook.go.PrepareWebhooks() called by\n- the webhookNotifier defined in services/webhook/notifier.go\n\nAnd this is how a workflow gets sent to a runner:\n\n- services/actions/workflows.go.Dispatch() calls\n- models/actions/run.go.InsertRun() to store the to happen action run in the database\n- [haven't figures this part out yet]\n\nI think this is what needs to be done:\n\n- add new notifier channel for finished action workflow\n- make webhookNotifier listen to the action workflow notification \n  - add new HookEventType\n  - implement settings for this new type of webhook\n- create mailNotifier listen to the action workflow notification \n  - [haven't figured this part out yet]\n- figure out where forgejo realizes that an action run finished or failed to start and emit the new signal\n- maybe add some more info to the database to remember when the last run failed and this one succeeded\n\nWhat do you think?\nI'd like to open a PR for this next week so any input is appreciated.\n\nUpdated investigation on how a workflow gets sent to a runner:\n\n- services/actions/workflows.go.Dispatch() calls\n- models/actions/run.go.InsertRun() to store the to happen action run in the database, this also increases the tasks version\n- runner calls FetchTasks route in routers/api/actoins/runner/runner.go.FetchTasks()\n- there forgejo checks if a new tasks exists by checking the tasksVersion the runner provides and the one in the database using models/actions/tasks_version.go.GetTasksVersionByScope()\n- when the versions differ that implies there could be tasks to be done we get a new task to do with services.actions.task.go.PickTask() and send that to the runner\n- there we call models/actions/task.go.CreateTaskForRunner()\n\n## How do job runs timeout:\n\nHow does Forgejo notice when a run succeeded or failed:\n\n- that info is stored in the `Status` field of the `ActionRun` database relation\n- the only place where that status changes is in [models.actions.run](http://models.actions.run).go.UpdateRun()\n- this is called (only the interesting calls that change the status) in \n  - routers.web.repo.actions.view.go.Rerun() and\n  - [models.actions.run](http://models.actions.run)\\_job.go.UpdateRunJob() called in a bunch of places\n\nWe are only interested in `ActionRun`, not `ActionRunJob`\n\n```go\n// don't need approval if the user has been approved before\nif count, err := db.Count[actions_model.ActionRun](ctx, actions_model.FindRunOptions{\n    RepoID:        repo.ID,\n    TriggerUserID: user.ID,\n    Approved:      true,\n}); err != nil {\n    return false, fmt.Errorf(\"CountRuns: %w\", err)\n} else if count > 0 {\n    log.Trace(\"do not need approval because user %d has been approved before\", user.ID)\n    return false, nil\n}\n```\n\n```go\nfunc GetLatestRun(ctx context.Context, repoID int64) (*ActionRun, error) {\n\tvar run ActionRun\n\thas, err := db.GetEngine(ctx).Where(\"repo_id=?\", repoID).OrderBy(\"id DESC\").Limit(1).Get(&run)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, fmt.Errorf(\"latest run: %w\", util.ErrNotExist)\n\t}\n\treturn &run, nil\n}\n```\n\nI completed my investigation on where to call the notification channel.\nI added my verdict on the call tree in braces below.\n\n```\n- (can't call notify) models/actions/run.go|392 col 6| func UpdateRun(ctx context.Context, run *ActionRun, cols ...string) error {\n    - (can't call notify) models/actions/run_job.go|157 col 13| if err := UpdateRun(ctx, run, \"status\", \"started\", \"stopped\"); err != nil {\n        part of models/actions/run_job.go|104 col 6| func UpdateRunJob(ctx context.Context, job *ActionRunJob, cond builder.Cond, cols ...string) (int64, error) {\n            - (not relvant as we don't change the status) models/actions/run.go|232 col 15| n, err := UpdateRunJob(ctx, job, builder.Eq{\"task_id\": 0}, \"status\", \"stopped\")\n            - (not relevant as only a new job is created) models/actions/task.go|316 col 15| if n, err := UpdateRunJob(ctx, job, builder.Eq{\"task_id\": 0}); err != nil {\n            - (doesn't change the state on action runs that are already done) models/actions/task.go|378 col 16| if _, err := UpdateRunJob(ctx, &ActionRunJob{\n            - (can't call notify) models/actions/task.go|442 col 15| if _, err := UpdateRunJob(ctx, &ActionRunJob{\n                part of models/actions/task.go|423 col 6| func StopTask(ctx context.Context, taskID int64, status Status) error {\n                - (can't call notify) models/actions/run.go|247 col 14| if err := StopTask(ctx, job.TaskID, StatusCancelled); err != nil {\n                    part of models/actions/run.go|190 col 6| func CancelPreviousJobs(ctx context.Context, repoID int64, ref, workflowID string, event webhook_module.HookEventType) error {\n                    - (can't call notify) models/actions/schedule.go|130 col 13| if err := CancelPreviousJobs(\n                        part of models/actions/schedule.go|122 col 6| func CleanRepoScheduleTasks(ctx context.Context, repo *repo_model.Repository, cancelPreviousJobs bool) error {\n                        - (*) routers/api/v1/repo/repo.go|1068 col 28| if err := actions_model.CleanRepoScheduleTasks(ctx, repo, true); err != nil {\n                        - (*) routers/web/repo/setting/setting.go|1037 col 27| if err := actions_model.CleanRepoScheduleTasks(ctx, repo, true); err != nil {\n                        - (*) services/actions/notifier_helper.go|142 col 27| if err := actions_model.CleanRepoScheduleTasks(ctx, input.Repo, true); err != nil {\n                        - (doesn't stop any runs as cancelPreviousJobs is false) services/actions/notifier_helper.go|507 col 27| if err := actions_model.CleanRepoScheduleTasks(ctx, input.Repo, false); err != nil {\n                        - (*) services/repository/setting.go|32 col 27| if err := actions_model.CleanRepoScheduleTasks(ctx, repo, true); err != nil {\n                    - (*) services/actions/notifier_helper.go|376 col 28| if err := actions_model.CancelPreviousJobs(\n                    - (*) services/actions/schedule_tasks.go|58 col 29| if err := actions_model.CancelPreviousJobs(\n                    - (*) services/repository/branch.go|380 col 28| if err := actions_model.CancelPreviousJobs(\n                    - (*) services/repository/branch.go|581 col 27| if err := actions_model.CancelPreviousJobs(\n                - (*) routers/web/repo/actions/view.go|524 col 28| if err := actions_model.StopTask(ctx, job.TaskID, actions_model.StatusCancelled); err != nil {\n                - (*) services/actions/clear_tasks.go|44 col 28| if err := actions_model.StopTask(ctx, task.ID, actions_model.StatusFailure); err != nil {\n            - (not relevant as we only set the status to StatusWaiting) routers/web/repo/actions/view.go|439 col 27| _, err := actions_model.UpdateRunJob(ctx, job, builder.Eq{\"status\": status}, \"task_id\", \"status\", \"started\", \"stopped\")\n            - (*a) routers/web/repo/actions/view.go|515 col 29| n, err := actions_model.UpdateRunJob(ctx, job, builder.Eq{\"task_id\": 0}, \"status\", \"stopped\")\n            - (not relevant as we only set the status to StatusWaiting) routers/web/repo/actions/view.go|558 col 29| _, err := actions_model.UpdateRunJob(ctx, job, nil, \"status\")\n            - (*a) services/actions/clear_tasks.go|91 col 28| _, err := actions_model.UpdateRunJob(ctx, job, nil, \"status\", \"stopped\")\n            - (*a) services/actions/job_emitter.go|62 col 32| if n, err := actions_model.UpdateRunJob(ctx, job, builder.Eq{\"status\": actions_model.StatusBlocked}, \"status\"); err != nil {\n    - (not relevant as we only change the status when it is currently done) routers/web/repo/actions/view.go|386 col 27| if err := actions_model.UpdateRun(ctx, run, \"started\", \"stopped\", \"previous_duration\"); err != nil {\n    - (not relevant as we don't change the status) routers/web/repo/actions/view.go|552 col 27| if err := actions_model.UpdateRun(ctx, run, \"need_approval\", \"approved_by\"); err != nil {\n```\n\n```\n- (can't call notify) models/actions/run.go|392 col 6| func UpdateRun(ctx context.Context, run *ActionRun, cols ...string) error {\n    - (can't call notify) models/actions/run_job.go|157 col 13| if err := UpdateRun(ctx, run, \"status\", \"started\", \"stopped\"); err != nil {\n        part of models/actions/run_job.go|104 col 6| func UpdateRunJob(ctx context.Context, job *ActionRunJob, cond builder.Cond, cols ...string) (int64, error) {\n            - (not relvant as we don't change the status) models/actions/run.go|232 col 15| n, err := UpdateRunJob(ctx, job, builder.Eq{\"task_id\": 0}, \"status\", \"stopped\")\n            - (not relevant as only a new job is created) models/actions/task.go|316 col 15| if n, err := UpdateRunJob(ctx, job, builder.Eq{\"task_id\": 0}); err != nil {\n            - (*a) [moved to services now] services/actions/task.go|378 col 16| if _, err := UpdateRunJob(ctx, &ActionRunJob{\n            - (*a) services/actions/task.go|130 col 29| if _, err := actions_model.UpdateRunJob(ctx, &actions_model.ActionRunJob{\n            - (not relevant as we only set the status to StatusWaiting) routers/web/repo/actions/view.go|439 col 27| _, err := actions_model.UpdateRunJob(ctx, job, builder.Eq{\"status\": status}, \"task_id\", \"status\", \"started\", \"stopped\")\n            - (*a) routers/web/repo/actions/view.go|515 col 29| n, err := actions_model.UpdateRunJob(ctx, job, builder.Eq{\"task_id\": 0}, \"status\", \"stopped\")\n            - (not relevant as we only set the status to StatusWaiting) routers/web/repo/actions/view.go|558 col 29| _, err := actions_model.UpdateRunJob(ctx, job, nil, \"status\")\n            - (*a) services/actions/clear_tasks.go|91 col 28| _, err := actions_model.UpdateRunJob(ctx, job, nil, \"status\", \"stopped\")\n            - (*a) services/actions/job_emitter.go|62 col 32| if n, err := actions_model.UpdateRunJob(ctx, job, builder.Eq{\"status\": actions_model.StatusBlocked}, \"status\"); err != nil {\n    - (not relevant as we only change the status when it is currently done) routers/web/repo/actions/view.go|386 col 27| if err := actions_model.UpdateRun(ctx, run, \"started\", \"stopped\", \"previous_duration\"); err != nil {\n    - (not relevant as we don't change the status) routers/web/repo/actions/view.go|552 col 27| if err := actions_model.UpdateRun(ctx, run, \"need_approval\", \"approved_by\"); err != nil {\n```\n\nSo what do we do?\nI'd say we do a mix of things.\nI think the locations labeled with `(*a)` can be amended with calls to the notification channel.\nThese locations are where UpdateRun or UpdateRunJob are called.\nSome of these calls don't change the status at all so they don't need to call the channel anyways.\n\nThen there's the thing with StopTask.\nI think it's best to move that function, CancelPreviousJobs and CleanRepoScheduleTasks to services/actions.\nSo propose moving these functions over:\n\n```\n- models/actions/task.go|423 col 6| func StopTask(ctx context.Context, taskID int64, status Status) error {\n- models/actions/run.go|190 col 6| func CancelPreviousJobs(ctx context.Context, repoID int64, ref, workflowID string, event webhook_module.HookEventType) error {\n- models/actions/schedule.go|122 col 6| func CleanRepoScheduleTasks(ctx context.Context, repo *repo_model.Repository, cancelPreviousJobs bool) error {\n```\n\nThese functions are pretty far detached from the actual database and contain a lot of logic.\nWhat do you say?\n","frontmatter":{"date":"Thursday, 16th October, 2025","title":"Forgejo Development","description":" Some stories of how I work on Forgejo. ","banner":"/social_banner/testing.png","title_banner":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgADBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHmIOMJx//EABkQAQEAAwEAAAAAAAAAAAAAAAEAERIhMf/aAAgBAQABBQJtZvXM9f/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABAR/9oACAEBAAY/Amv/xAAZEAADAQEBAAAAAAAAAAAAAAAAAREhMVH/2gAIAQEAAT8hRchHpScMwCeUfQ//2gAMAwEAAgADAAAAEO/f/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAQACAQUAAAAAAAAAAAAAAREAMSFBUWFxkf/aAAgBAQABPxAUAG7u7rFkCaUhfuJaETCBQzp4ygOPWImnYz//2Q=="},"images":{"fallback":{"src":"/static/a510114e0f227411627e203a1332f813/204db/alpha_whiskey.jpg","srcSet":"/static/a510114e0f227411627e203a1332f813/fa695/alpha_whiskey.jpg 480w,\n/static/a510114e0f227411627e203a1332f813/9f3ff/alpha_whiskey.jpg 960w,\n/static/a510114e0f227411627e203a1332f813/204db/alpha_whiskey.jpg 1920w","sizes":"(min-width: 1920px) 1920px, 100vw"},"sources":[{"srcSet":"/static/a510114e0f227411627e203a1332f813/95a23/alpha_whiskey.webp 480w,\n/static/a510114e0f227411627e203a1332f813/42d4c/alpha_whiskey.webp 960w,\n/static/a510114e0f227411627e203a1332f813/2136b/alpha_whiskey.webp 1920w","type":"image/webp","sizes":"(min-width: 1920px) 1920px, 100vw"}]},"width":1920,"height":1281}}},"title_banner_horizontal_position":"20%","title_banner_vertical_position":"80%","version":"1.0.0"}}},"pageContext":{"id":"9283e0c4-5bf5-5483-be21-e29b94a8d758","frontmatter":{"type":"article","title":"Forgejo Development","description":" Some stories of how I work on Forgejo. ","banner":"/social_banner/testing.png","thumb":"../../../static/social_banner/testing.png","title_banner":"../../images/photography/alpha_whiskey.jpg","title_banner_horizontal_position":"20%","title_banner_vertical_position":"80%","slug":"forgejo","date":"2025-10-16T00:00:00.000Z","listed":true,"version":"1.0.0"}}},"staticQueryHashes":["1754054404","1995789189","475732191"],"slicesMap":{}}