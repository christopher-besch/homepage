{"componentChunkName":"component---src-templates-article-tsx-content-file-path-src-articles-13-mc-missile-mc-missile-md","path":"/articles/mc_missile/","result":{"data":{"mdx":{"body":"\nimport compensate_gravity_diagram from \"./compensate_gravity_diagram.png\";\nimport compensate_gravity_theta_plot from \"./compensate_gravity_theta_plot.png\";\nimport sphere_ray_intersection_diagram from \"./sphere_ray_intersection_diagram.png\";\nimport sphere_ray_projection_diagram from \"./sphere_ray_projection_diagram.png\";\n\nimport buchel_air_strike_on_end_city from \"./buchel_air_strike_on_end_city.mp4\";\nimport buchel_air_strike_on_enderman_enderman_view from \"./buchel_air_strike_on_enderman_enderman_view.mp4\";\nimport direct_aerial_presentation from \"./direct_aerial_presentation.mp4\";\nimport direct_presentation from \"./direct_presentation.mp4\";\nimport none_presentation from \"./none_presentation.mp4\";\nimport straight_presentation from \"./straight_presentation.mp4\";\nimport straight_wo_gravtiy_presentation from \"./straight_wo_gravtiy_presentation.mp4\";\nimport top_stromel_kill from \"./top_stromel_kill.mp4\";\nimport top_true_presentation from \"./top_true_presentation.mp4\";\nimport top_wov_presentation from \"./top_wov_presentation.mp4\";\n\n<AutoPlayVideo src={top_stromel_kill} width={1920} height={1080} />\n\nCue [Soothing Minecraft — Relaxing Farm Morning](https://youtu.be/xLo-BrCh7JQ).\nI'm tending the fields, watching the river flow.\nMy brother walks by, saying hi.\nWhat's missing?\n\nA brother-seeking missile with an explosive warhead enough to crack his cute Netherite armor, of course!\nThis is my journey of developing such a thing with the [mc_missile](https://codeberg.org/christopher-besch/mc_missile) Minecraft mod.\nFollow this article and you too will have a [fire-and-forget](https://en.wikipedia.org/wiki/Fire-and-forget), [top-attack](https://en.wikipedia.org/wiki/Top-attack), [Infrared-homing](https://en.wikipedia.org/wiki/Infrared_homing) missile at your disposal.\n\n<Spacer />\n\n# The Starting Point\nThe server we're playing on runs the [mc_missile](https://codeberg.org/christopher-besch/mc_missile) Minecraft mod.\nIt allows all players to program guided missiles and fire them from a [crossbow](https://minecraft.wiki/w/Crossbow) or [dispenser](https://minecraft.wiki/w/Dispenser).\n\nA missile is built from components, each with a price tag and effects on the missile.\nFor us only the *rocket motor*, *air frame* and *seeker head* matter.\n\nLike the player (including my brother) the missile is an [entity](https://minecraft.wiki/w/Entity) in Minecraft.\nThe missile has\n-   a position $p = \\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix} \\in \\mathbb{R}^3$ (with the elevation $p_2$),\n-   velocity $v \\in \\mathbb{R}^3$,\n-   pitch $\\theta \\in [-90, 90]$ and\n-   yaw $\\psi \\in [-180, 180]$.\n\n    These angles are in degrees and there's no roll.\n    Additionally, they are the negated [angles](https://minecraft.wiki/w/Rotation) displayed in the [Mincraft F3 Menu](https://minecraft.wiki/w/Debug_screen).\n    That's because projectiles have flipped headings for some reason:\n    $\\theta=90$ is up, $\\theta=-90$ down and $\\psi \\in \\{-180, 180\\}$ is north, $\\psi = 90$ east, $\\psi = 0$ south and $\\psi = -90$ west.\n\nMinecraft updates the missile's state every tick (20 times a second).\nThe update in tick $t \\in \\mathbb{N}_0$ is separated into three stages:\n1.  Receive the control input:\n    The missile's only input method is an unrealisticly beefy [control moment gyroscope](https://en.wikipedia.org/wiki/Control_moment_gyroscope).\n    So the player's guidance code produces a requested change in pitch $\\theta_{in}$ and yaw $\\psi_{in}$.\n    It has no direct control over the missiles position, velocity, or thrust — only the rotation.\n\n2.  Update the missile's state:\n    The gyroscope is powerful but not overly powerful.\n    When the control input is too large (larger than $M_r$ defined by the airframe), it is scaled down linearly:\n    $$\n    \\begin{aligned}\n    l &= \\sqrt{\\theta_{in}^2 + \\psi_{in}^2} \\\\\n    \\begin{pmatrix} \\theta_{in} \\\\ \\psi_{in} \\end{pmatrix} \n      &\\rightarrow \\max{\\left\\{\\frac{M_r}{l}, 1\\right\\}}\n       \\begin{pmatrix} \\theta_{in} \\\\ \\psi_{in} \\end{pmatrix}.\n    \\end{aligned}\n    $$\n    With this, Minecraft applies the adjusted control input plus some random noise.\n    $$\n    \\begin{aligned}\n    \\theta &\\rightarrow \\theta + \\theta_{in} + N_r \\\\\n    \\psi   &\\rightarrow \\psi + \\psi_{in} + N_r \\\\\n    \\end{aligned}\n    $$\n    Each $N_r$ is normally distributed noise dependent on the air frame used by the missile.\n    So you don't have perfect control over the missiles rotation, there is always some variance.\n\n    Now the acceleration $a \\in \\mathbb{R}^3$ can be calculated from the rotation vector $r \\in \\mathbb{R}^3$, the current thrust $T(t) \\in [0, \\infty)$ and gravity $g = \\begin{pmatrix} 0 \\\\ -\\|g\\| \\\\ 0 \\end{pmatrix} \\in \\mathbb{R}^3$.\n    $$\n    \\begin{aligned}\n    r & =\n    \\begin{pmatrix}\n        \\sin(\\psi) \\cos(\\theta) \\\\\n        \\sin(\\theta) \\\\\n        \\cos(\\psi) \\cos(\\theta)\n    \\end{pmatrix} \\\\\n    a & = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} \\\\\n      & = \\left(T(t) + N_T \\right) \\cdot r + g\n    \\end{aligned}\n    $$\n    $N_T$ is normally distributed noise and like the thrust function $T$ defined by the rocket motor.\n\n    Lastly, the velocity and position are updated with the airframe defined drag $d \\in [0, 1)$.\n    $$\n    \\begin{aligned}\n    v &\\rightarrow (1 - d) \\cdot (v + a) \\\\\n    p &\\rightarrow p + v\n    \\end{aligned}\n    $$\n\n3.  Now that the missile's state has been updated Minecraft sends that state to the player's guidance code.\n    All these values contain some variance, too — depending on the missile's [inertial measurement unit](https://en.wikipedia.org/wiki/Inertial_measurement_unit).\n    The guidance server has a little less than 50ms to send the rotation change for the next tick.\n\nIn the first tick ($t=0$), the missile doesn't have guidance input yet and thus flies straight ahead with the velocity and rotation of the shooter.\nNo variance is applied here.\n\nDisclaimer:\nAs you can see the flight dynamics of Minecraft missiles don't have anything to do with *real* missiles.\nThere are no aerodynamic aspects simulated at all, for example.\nAll we do is magically rotate a rock in vacuum.\nThus the guidance code explained in this article can only be applied to the toy world that is Minecraft and nothing else.\nStill, it'll be fun!\n\n<AutoPlayVideo src={none_presentation} width={1920} height={1080} />\n\nSo what happens when we write the simplest guidance code we can think of: doing nothing.\nWe all like oxidized weapons so let's use Rust for this:\n```rust\nlet mut control_input = ControlInput {\n    pitch_turn: 0.0,\n    yaw_turn: 0.0,\n    // --snip--\n};\n```\n\nWe're probably more likely to blow ourselves up than my brother like this.\n(A cheaper airframe would take an even less predictable path.)\n\n<Spacer />\n\n# Flying a Straight Line\n\n<AutoPlayVideo src={straight_wo_gravtiy_presentation} width={1920} height={1080} />\n\nLet's start with compensating the rotation noise $N_r$.\nWe can simply record the missile's heading in the first tick\n```rust\nself.target_pitch = missile_state.pitch;\nself.target_yaw = missile_state.yaw;\n```\nand in all following ticks measure the missile's heading deviation and correct for it.\n```rust\nlet mut control_input = ControlInput {\n    pitch_turn: self.target_pitch - missile_state.pitch,\n    yaw_turn: self.target_yaw - missile_state.yaw,\n    // --snip--\n};\n```\n\nNow the missile flies in a consistently straight line.\nIt just isn't flying where we're pointing our crosshair (at my brother).\n\n<Spacer />\n\n# Compensating for Gravity\n\n<HalfImage src={compensate_gravity_diagram} />\n\nAs we can see we only have to adjust our pitch:\nThere's no gravity messing with our yaw.\nGiven the pitch $\\alpha \\in [-90, 90]$ of a desired acceleration (towards my brother) what pitch $\\theta$ should the rocket point in?\n\nAssume, without loss of generality, $\\psi = 90$ and ignore thrust variance.\nAlso, assume $T(t) > \\|g\\|$ (otherwise we'd have to calculate a parabola when our initial velocity suffices).\nThen $a_3 = 0$ and we can write:\n$$\n\\begin{aligned}\n\\tilde{a} &= \\begin{pmatrix} a_1 \\\\ a_2 \\end{pmatrix} \\\\\n          &= \\|g\\| \\cdot \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} +\n             T(t) \\cdot \\begin{pmatrix} \\cos(\\theta) \\\\ \\sin(\\theta) \\end{pmatrix}\n\\end{aligned}\n$$\n\nand with some trigonometry:\n$$\n\\begin{aligned}\n\\tan(\\alpha) &= \\frac{a_2}{a_1} \\\\\n             &= \\frac{T(t) \\cdot \\sin(\\theta) - \\|g\\|}{T(t) \\cdot \\cos(\\theta)}.\n\\end{aligned}\n$$\n\nThere's no closed-form solution for $\\theta$.\nThe best we can do is rewrite it like this and use a numerical root-finding approach like [Newton's method](https://en.wikipedia.org/wiki/Newton's_method):\n$$\n\\frac{\\|g\\|}{T(t)} + \\cos(\\theta) \\tan(\\alpha) - \\sin(\\theta) = 0.\n$$\n\n<HalfImage src={compensate_gravity_theta_plot} />\n\nHow do we do that with Rust?\nWe use Python, calculate a lookup-table resolving $\\left(\\frac{\\|g\\|}{T(t)}, \\alpha\\right) \\mapsto \\theta$ and use that in Rust.\n```python\nimport numpy as np\nfrom scipy import optimize\n\ndef f(x, thrust, target_pitch_rad, g):\n    return ((g/thrust) + np.tan(target_pitch_rad)*np.cos(x) - np.sin(x))\n\ndef fprime(x, thrust, target_pitch_rad, g):\n    return (-np.tan(target_pitch_rad)*np.sin(x) - np.cos(x))\n\n# Set the gravity to 1 so that we can easily scale the effective thrust in rust.\n# effective_thrust = thrust/g\ng = 1\nthrusts = np.linspace(1, 5, 30)\ntarget_pitches_deg = np.linspace(-90, 90, 30)\ntarget_pitches_rad = np.deg2rad(target_pitches_deg)\nthrusts_grid, target_pitches_rad_grid = np.meshgrid(thrusts, target_pitches_rad)\ntarget_pitches_deg_grid = np.rad2deg(target_pitches_rad_grid)\n\nheading_pitches_rad = optimize.newton(\n    f,\n    target_pitches_rad_grid,\n    fprime=fprime,\n    args=(thrusts_grid, target_pitches_rad_grid, g)\n)\nheading_pitches_deg = np.rad2deg(heading_pitches_rad)\n```\n\n<AutoPlayVideo src={straight_presentation} width={1920} height={1080} />\n\nAs you can see in the colourful plot, when the missile has high thrust we don't really have to correct for gravity at all and our yellow line is basically straight.\nWhen the thrust is almost as strong as the gravity, we have to adjust our heading a lot more aggressively.\n\nPretty nice!\n\n<Spacer />\n\n## IrSeeker and Top Attack\nOne problem with the above design is that errors along the way are added up and make the missile miss sometimes.\nWe can fix this with the `IrSeekerM` missile component, which provides my brother's position every tick (when there's a line-of-sight).\nThen the missile can update it's target heading and *fix* it's past inaccuracies.\n\nWith the missile's position $p$ and some target coordinates $k$ you can calculate the desired pitch $\\alpha$ and yaw $\\psi$ with the below trigonometry.\n```rust\npub async fn calc_alpha_psi(target_direction: Vec3) -> (f64, f64) {\n    // projected onto the horizontal plane\n    let vec_horizontal = Vec3::new(target_direction.x, 0.0, target_direction.z);\n    let mut alpha = vec_horizontal\n        .normalize()\n        .dot(&target_direction.normalize())\n        .acos()\n        .to_degrees();\n    if target_direction.y < 0.0 {\n        alpha *= -1.0;\n    }\n    let psi = target_direction.x.atan2(target_direction.z).to_degrees();\n    (alpha, psi)\n}\n```\nAnd then the gravity corrected pitch $\\theta$, $\\theta_{in}$ and $\\psi_{in}$ to make the missile accelerate towards the target.\n\n<AutoPlayVideo src={top_wov_presentation} width={1920} height={1080} />\n\nI had some fun with this and implemented top-attacks, where the missile rises into the air before striking the ground at high speed.\nAt some point the missile switches from *flying to some block in the sky* to *flying towards my brother*.\n\nOh, no, our missile isn't hitting any more!\nWhy is that?\n\n<Spacer />\n\n# Velocity-Awareness\n\n<HalfImage src={sphere_ray_intersection_diagram} />\n\nThe issue is that accelerating towards my brother isn't actually what we want:\nWe want to align our velocity $v$ so that it moves us closer towards the target.\nOur previous calculation simply points our acceleration vector towards the target.\nWhen $\\|v\\| = 0$ or $v$ is already pointing in the right direction that is correct.\nBut at the apogee of a top-attack our missile's velocity is pointing towards the sky, not the target; so we miss.\n\nSay our target is at $y \\in \\mathbb{R}^3$ and we are at $p$.\nThen we're asking for our new velocity $\\tilde{v} = v + a$ to fulfil\n$$\n\\begin{aligned}\n\\tilde{v} &= r \\cdot u \\\\\n\\end{aligned}\n$$\nwith $r \\in (0, \\infty)$ and $u = y - p$.\n\nBecause of gravity the exact length of $a$ is unfortunately not known at this point.\nA good approximation is to ignore gravity for now and use\n$$\n\\|a\\| \\approx T(t).\n$$\n\nYou might already notice that $r \\cdot u$ defines a line in direction $u$ (from the missile towards my brother) and $v + a$ a sphere around $v$ with radius $T(t)$.\nSo we're asking for a line-sphere intersection.\nYou could either do the math yourself or use [Wikipedia](https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection) and come up with\n$$\n\\begin{aligned}\nr_{rad} &=&& (2u^Tv)^2 - \\\\\n        & && 4\\|u\\|^2 \\left(\\|v\\|^2 - T(t)^2\\right) \\\\\nr_{1,2} &=&& \\frac{2u^Tv \\pm \\sqrt{r_{rad}}}\n                {2\\|u\\|^2}.\n\\end{aligned}\n$$\nI use the larger $r_{1,2}$ because then we're also accelerating towards the target while keeping our velocity correctly pointed.\n(You could also use the smaller one and accelerate away from the target in case you want to break.)\nWith this I know where to accelerate:\n$$\n\\frac{a}{\\|a\\|} = \\frac{r \\cdot u - v}{\\|r \\cdot u - v\\|}.\n$$\nWe again need to compensate for gravity to calculate the right missile rotation.\n\n<HalfImage src={sphere_ray_projection_diagram} />\n\nOne last problem:\nWhen the above radical $r_{rad}$ is negative we can't calculate the square-root.\nThis is the case when the sphere and line don't intersect at all.\nFor us that means our current velocity is so far off and our thrust so weak there's no way we could reach the requested velocity this tick.\nIn this case the best we can do is take the point of our circle closest to our line.\nThat's equivalent to projecting $v$ orthographically onto $u$:\n$$\n\\begin{aligned}\nu_p               &= \\frac{v^Tu}{\\|u\\|^2} \\cdot u \\\\\n\\frac{a}{\\|a\\|}   &= \\frac{u_p - v}{\\|u_p - v\\|}\n\\end{aligned}\n$$\n\nAgain we need to compensate for gravity just like before.\nDoing this for a few ticks should hopefully be enough to at some point have a positive radical and use the line-sphere intersection then.\nFun fact:\nIn this situation we aren't accelerating towards the target at all.\nWe're completely focused on getting us on course, first.\n\n<AutoPlayVideo src={top_true_presentation} width={1920} height={1080} />\n\nNow our top attack works all the time.\n(Minus that one time the proximity fuse triggered too early, whoops.)\n\n<AutoPlayVideo src={direct_presentation} width={1920} height={1080} />\n\nAnd direct attacks work, too.\n\n<AutoPlayVideo src={direct_aerial_presentation} width={1920} height={1080} />\n\nEven aerial brothers can be engaged!\nThis only works with this design because the rocket motor is so crazily powerful.\nIt costs something like five diamonds per rocket alone!\nAnything cheaper wouldn't work like this.\n\n<Spacer />\n\n# Other Ideas\n\n<AutoPlayVideo src={buchel_air_strike_on_end_city} width={1920} height={1080} />\n\nThere's a lot you could improve upon.\nA few of my ideas:\n1. Use a different war head, the mc_missile mod offers many options.\n2. Implement a boost phase where the missile clears the trees and buildings the shooter stands under before rising into the sky.\n3. Guess the target's position based on the current direction (works without top-attack).\n   Then you can save on the expensive seeker.\n4. Do some parabola calculation and use a cheaper rocket motor that only has a short burn duration in the beginning.\n5. Implement [Proportional navigation](https://en.wikipedia.org/wiki/Proportional_navigation) to shoot down moving and aerial targets.\n6. Use [lock-on after launch](https://en.wikipedia.org/wiki/Lock-on_after_launch) to fire at targets without visual contact.\n8. Generally use cheaper components and deal with the implications.\n9. much, much more...\n\nI encourage you to give the [mc_missile](https://codeberg.org/christopher-besch/mc_missile) Minecraft mod a go — it's real fun!\n\n<Spacer />\n\n# PS\n\n<AutoPlayVideo src={buchel_air_strike_on_enderman_enderman_view} width={1920} height={1080} />\n\nPsst, my [entire guidance code](https://codeberg.org/christopher-besch/mc_missile_guidance) is open-source; just don't tell my brother.\n\n### PPS\n\nMy brother is actually really cool.\nThanks for *testing* my missiles!\n","frontmatter":{"date":"Friday, 6th June, 2025","title":"Guided Missiles in Minecraft","description":" I'm having a stab at designing an enitity seeking missile in Minecraft with the mc_missile mod.\nOr: How I blew up my brother. ","banner":"/social_banner/mc_missile.png","title_banner":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAUBAgT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHRKiwxFQf/xAAYEAEAAwEAAAAAAAAAAAAAAAABABESEP/aAAgBAQABBQI7pmmrZ//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAAAAxEP/aAAgBAQAGPwLaqv/EABoQAQEAAgMAAAAAAAAAAAAAAAEAEZExQWH/2gAIAQEAAT8hRKSmYw89z2l7t3//2gAMAwEAAgADAAAAEDzP/8QAFxEBAAMAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxCKY//EABYRAAMAAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPxCMjP/EABoQAAICAwAAAAAAAAAAAAAAAAERAFEQMYH/2gAIAQEAAT8QQ3EM5yINn7AoV2n/2Q=="},"images":{"fallback":{"src":"/static/33f4be969e10f0881bbee084dd30df94/a764f/alpha_xray.jpg","srcSet":"/static/33f4be969e10f0881bbee084dd30df94/fb67e/alpha_xray.jpg 480w,\n/static/33f4be969e10f0881bbee084dd30df94/3059d/alpha_xray.jpg 960w,\n/static/33f4be969e10f0881bbee084dd30df94/a764f/alpha_xray.jpg 1920w","sizes":"(min-width: 1920px) 1920px, 100vw"},"sources":[{"srcSet":"/static/33f4be969e10f0881bbee084dd30df94/3a3a2/alpha_xray.webp 480w,\n/static/33f4be969e10f0881bbee084dd30df94/bde8a/alpha_xray.webp 960w,\n/static/33f4be969e10f0881bbee084dd30df94/c512e/alpha_xray.webp 1920w","type":"image/webp","sizes":"(min-width: 1920px) 1920px, 100vw"}]},"width":1920,"height":1080}}},"title_banner_horizontal_position":"80%","title_banner_vertical_position":"100%","version":"1.0.0"}}},"pageContext":{"id":"083a9374-a6ce-56fe-9a3f-b03f230c824d","frontmatter":{"type":"article","title":"Guided Missiles in Minecraft","description":" I'm having a stab at designing an enitity seeking missile in Minecraft with the mc_missile mod.\nOr: How I blew up my brother. ","banner":"/social_banner/mc_missile.png","thumb":"../../../static/social_banner/mc_missile.png","title_banner":"../../images/photography/alpha_xray.jpg","title_banner_horizontal_position":"80%","title_banner_vertical_position":"100%","slug":"mc_missile","date":"2025-06-06T00:00:00.000Z","listed":true,"version":"1.0.0"}}},"staticQueryHashes":["1995789189","2480137602","475732191"],"slicesMap":{}}