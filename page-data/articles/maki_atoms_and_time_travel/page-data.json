{"componentChunkName":"component---src-templates-article-tsx-content-file-path-src-articles-02-maki-atoms-and-time-travel-maki-atoms-and-time-travel-md","path":"/articles/maki_atoms_and_time_travel/","result":{"data":{"mdx":{"body":"import full_showcase_01 from \"./full_showcase_01.mp4\";\nimport full_showcase_01_poster from \"./full_showcase_01_poster.png\";\n\nimport init from \"./01_init.mp4\";\nimport create_cube from \"./02_create_cube.mp4\";\nimport show_cube from \"./03_show_cube.mp4\";\nimport colouring from \"./04_colouring.mp4\";\nimport translate_cube from \"./05_translate_cube.mp4\";\nimport smooth_translation from \"./06_smooth_translation.mp4\";\nimport time_travel from \"./07_time_travel.mp4\";\n\nimport fly_around_01 from \"./fly_around_01.mp4\";\nimport fly_around_02 from \"./fly_around_02.mp4\";\n\nTo create animations for technical concepts, one is advised to use graphics software with a programmatic approach.\nWhile these provide the required precision, they suffer from an inherent disconnect between input and output.\nWYSIWYG programs avoid this detachment with interactivity at the cost of precision.\n\nThe purpose of this article is to outline how a program for interactive and programmatic animation development can be implemented.\nTo experiment with different technologies and programming paradigms, I created a developmental implementation called Maki.\nThis article outlines Maki's design decisions and discusses planned future development.\n\n### Table of Contents\n<AutoPlayVideo src={full_showcase_01} poster={full_showcase_01_poster} />\n\n{\n<ul>\n<li><a href=\"#maki\">Maki</a>\n<ul>\n<li><a href=\"#walkthrough\">Walkthrough</a></li>\n</ul>\n</li>\n<li><a href=\"#clear-ownership\">Clear Ownership</a></li>\n<li><a href=\"#renderer-abstraction\">Renderer Abstraction</a></li>\n<li><a href=\"#multi-threading\">Multi Threading</a></li>\n<li><a href=\"#atoms\">Atoms</a>\n<ul>\n<li><a href=\"#difference-array\">Difference Array</a></li>\n<li><a href=\"#atom-chain\">Atom Chain</a></li>\n<li><a href=\"#chrono-syncs\">Chrono Syncs</a></li>\n</ul>\n</li>\n<li><a href=\"#templates\">Templates</a>\n<ul>\n<li><a href=\"#templated-memory\">Templated Memory</a></li>\n<li><a href=\"#rendering-atoms\">Rendering Atoms</a></li>\n<li><a href=\"#why-templates\">Why Templates?</a></li>\n</ul>\n</li>\n<li><a href=\"#path-of-an-atom\">Path of an Atom</a></li>\n<li><a href=\"#conclusion-and-future-plans\">Conclusion and Future Plans</a></li>\n<li><a href=\"#appendix\">Appendix</a></li>\n</ul>\n}\n\n# Maki\n\n- **Extensibility**,\n- **performance**,\n- **ease of use**,\n- **strict type and thread safety**,\n- **clear ownership** and the\n- **fear of loosing (type) information** form Maki's main ideals.\n\nI chose C++ because it enforces **strict rules** and offers handy containers, algorithms and many light-weight abstractions, aiding in the development of a complex system, without compromising on **performance**.\n\nThe goal of [Maki](https://github.com/christopher-besch/maki) is to allow the user to create 3D animations using Python;\nwhile the user is constructing their animation in an interactive shell, Maki shows the current status of the scene in a separate window.\nHere the user is able to freely move the camera.\nIn addition to spacial movement, Maki provides the ability to *jump in time*;\nThe user can decide which frame of the animation should be played.\n\nThis allows an **easy to use** workflow, minimizing the time between defining animations and playing with the results.\n\n## Walkthrough\n<AutoPlayVideo src={init} />\n\nTo start working with Maki, one has to initialize it.\nThis defines the rendering API to be used and creates a window of the specified size.\n\n<AutoPlayVideo src={create_cube} />\n\nOnce that is done, you can create an atom.\nThis call to `add_cuboid_atom` returns a handle to the cuboid.\nBut you will see...that you don't see anything.\n\n<AutoPlayVideo src={show_cube} />\n\nThat's because you've only created the atom;\nyou still have to tell Maki to actually render it.\nThis call to `show_cuboid_atom` orders Maki to start showing the atom at frame `1`.\n\n<AutoPlayVideo src={colouring} />\n\nWe can also change the colour.\nEach call again needs to know what frame it should be applied to.\n\n<AutoPlayVideo src={translate_cube} />\n\nOur cube can also be moved.\nBut Maki currently only supports instant movement—\"teleporting\" from one frame to the next.\n\n<AutoPlayVideo src={smooth_translation} />\n\nSmooth transitions have to be implemented on the Python side. \nThis quick implementation performs just that; it smoothly shifts the cube from frame `60` to frame `200`.\n\n<AutoPlayVideo src={time_travel} />\n\nAs you can see, Maki currently shows the 199th frame.\nBut now I'm applying another downward translation from frame `5` to `50`.\nThis downward shift lies in the past, so we expect the cube to be in a lower position in the present.\nAnd that's exactly what we see:\nThe moment the shift is being applied, Maki performs a [Chrono Sync](#chrono-sync) and the cube changes it's position.\nThe past was altered, and we see the repercussions in the present.\n\n<Quote text=\"The past was erased, the erasure was forgotten, the lie became truth.\" author=\"1984\" />\n\n\n<Spacer />\n\n# Clear Ownership\n\nShared ownership, where multiple classes own a single resource, are convenient to implement;\n*everything has access to everything*, so the optimum of possibilities has been achieved.\nBut those programs, in which *everything owns everything* and *everything calls everything* are very difficult to reason about and tend to be less performant.\n\nWhen instead every resource is owned by only one object, that object's constructor acquires the resources and the destructor subsequently frees them.\nThis programming technique (called [RAII](https://en.cppreference.com/w/cpp/language/raii) by the C++ committee for silly names) leaves no need for any garbage collection.\n\nBut in some situations the same resource has to be *used* by multiple objects.\nWith an emphasis on *used*;\nthese situations don't necessarily warrant the use of shared ownership.\nInstead the resource can be *borrowed*.\nFor example, without going into detail of what these classes actually do:\nA `RenderDriver` owns a `Renderer` and an `AtomDispenser`.\nThe `AtomDispenser` needs the `Renderer` to perform its task, so it *borrows* it from the `RenderDriver`.\nAnd because both the `AtomDispenser` and the `Renderer` are owned by the same `RenderDriver`, the `AtomDispenser` can rest assured that all its resources are (still) available.\n\nThis member function lends the `Renderer` to an `AtomDispenser`:\n```cpp\nvoid AtomDispenser::create_all_atom_renderers(Renderer* renderer)\n{\n    ...\n}\n```\n\nBut not having to garbage collect isn't the only performance advantage.\nA **clear ownership model** also bestows a definitive purpose on each function and object.\nObjects are restricted to the resources they need to fulfill their task:\nAnything they don't need, they don't have access to.\nThis reduces side-effects and consequently improves debuggability.\n\nKnowing in which context what data is being used, allows the programmer to optimize memory accesses for just these contexts.\n\n<Quote text=\"Software does not run in a magic fairy aether powered by the fever dreams of CS PhDs.\" author=\"Mike Acton\" />\n\nSoftware runs on hardware, hardware that has certain tastes.\nSo if you intend to write fast software, you should base your data layout on the silicon it's supposed to run on.\nOnly because two concepts have something in common in the mental model of yours, doesn't mean their data representation has to have anything to do with each other.\nIn fact they may vary wildly.\nThat's why, what a concept's implementation should be based on, is the hardware in use, not the mental model of any programmer.\n\nTherefore a **clear ownership** model is easier to reason about and the foundation for high performing software.\nMemory layout will also play a major role in [Why Templates?](#why-templates).\n\n# Renderer Abstraction\nEven though Maki is currently using OpenGL only, different rendering APIs (like Vulcan, Metal or DirectX) can easily be added.\nTo achieve this many low-lever rendering concepts are implemented using abstract classes (e.g. `Shader`, `Renderer` and `VertexBuffer`).\nThe actual API specific implementations (e.g. `OpenGLShader`) can be found in a subdirectory:\n```\n.\n├── opengl\n│   ├── opengl_buffer.cpp\n│   ├── opengl_buffer.h\n│   ├── opengl_renderer.cpp\n│   ├── opengl_renderer.h\n│   ├── ...\n├── buffer.cpp\n├── buffer.h\n├── renderer.cpp\n├── renderer.h\n├── ...\n```\nThe abstract classes define the static function `create` to create an instance of the appropriate class:\n```cpp\nIndexBuffer* IndexBuffer::create(uint32_t count, const uint32_t* indices)\n{\n    switch(Renderer::get_renderer_impl()) {\n    ...\n    case Renderer::Implementation::opengl:\n        return new OpenGLIndexBuffer(count, indices);\n    default:\n        MAKI_RAISE_CRITICAL(\"The requested renderer implementation is not supported.\");\n        return nullptr;\n    }\n}\n```\nThe static function `Renderer::set_renderer_impl` is used to globally define the renderer API at Maki's boot up.\n\nThis decision, which renderer API should be used, is performed at runtime.\nThat way the user can decide which implementation to use:\nEven so you're on Windows, you might want to use OpenGL instead of DirectX because you have custom shaders written in GLSL.\n\nThe situation is different for the platform, i.e. the window handling mechanism, which is selected based on the type of target system.\nGLFW can be used on Linux, Windows and the MacOS;\nWebAssembly might need something else.\nThe crucial difference to the renderer API is that the decision, which platform is to be used, can be made at compile time.\nBy using preprocessor statements to only compile the required platform, the switch statement can be avoided and some runtime overhead removed.\n```cpp\n#if PROJECT == glfw\n    GLFWwindow* m_handle {nullptr};\n#endif\n```\nThis macro has to be set using the `-Dplatform=glfw` flag at compilation.\n\nAs you can see, **extensibility** lies at the heart of Maki.\n\n# Multi Threading\n<AutoPlayVideo src={fly_around_01} />\n\nThere are always two things happening concurrently:\n\n1. accepting new atoms or changing existing ones and\n2. rendering the scene or handling user interaction.\n\nThis is why it makes sense to use two threads, a control and a render thread.\nSince OpenGL doesn't allow multiple threads to use the same context, only the render thread is allowed to perform render calls.\nThe control thread on the other hand is the only one Python can directly interface with.\nConsequently, data has to be safely exchanged between the two threads.\nIn addition to that, each thread should under no circumstances be allowed to perform actions outside of its jurisdiction.\n\nWhen Maki wakes up, the first order of business is to initialize the (main) control thread, after which the render thread is to be created.\nThis initialization includes calling `SET_THREAD_TYPE_CONTROL()` and `SET_THREAD_TYPE_RENDER()` from the respective threads.\nThese preprocessor macros define a thread local variable.\nSince each thread has it's own thread local variables, they can be used to deduce the type of any thread.\n\nEvery function can then be equipped with a call to `MAKI_ASSERT_CTRL_THREAD()` or `MAKI_ASSERT_RNDR_THREAD()`, which asserts that the correct thread is being used.\nSince these checks are being removed for `Release` mode and are only included in `Debug` builds (which can be specified using the `-DCMAKE_BUILD_TYPE=Release` flag) there is no runtime overhead.\n\n```cpp\n#ifndef NDEBUG\n...\n#define MAKI_ASSERT_CTRL_THREAD()                              \\\n    MAKI_ASSERT_CRITICAL(g_thread_type == ThreadType::control, \\\n                         \"This function can only be called from the control thread.\")\n#define MAKI_ASSERT_RNDR_THREAD()                             \\\n    MAKI_ASSERT_CRITICAL(g_thread_type == ThreadType::render, \\\n                         \"This function can only be called from the render thread.\")\n#else\n...\n// don't do anything in release mode\n#define MAKI_ASSERT_CTRL_THREAD()\n#define MAKI_ASSERT_RNDR_THREAD()\n\n#endif\n```\n\nTo prevent race conditions (uncontrolled, concurrent access to the same resource) mutexes are being used.\nThese \"mutual exclusion objects\" allow the locking of a resource for the duration of its use.\nIn addition to this locking operation being a rather expensive one, all other threads in need of that resource are being stalled.\nTherefore the use of mutexes ought to be minimized.\n\nThese two precautions, preventing the threads from running incorrect functions and accessing resources at the same time, form the basis for Maki's **thread safety**.\n\n<Spacer />\n\n# Atoms\nJust like how real atoms were thought to be the indivisible unit of the universe, atoms are the smallest renderable unit in Maki.\nA collection of them form a frame, multiple of which form an entire scene, which can be rendered to a video file.\n\nAn `Atom` stores all the data required to render that atom.\nThis mainly includes vertex data, like position or colour.\n\n```cpp\nstruct Atom {\n    bool render {false};\n\n    // to be defined by implementation:\n    // static constexpr const char* type_name {\"Atom\"};\n};\n\nstruct QuadrilateralAtom: public Atom {\n    std::array<vec3, 4> ver_pos {\n        vec3 {-1.0f, -1.0f, +0.0f},  // bottom left\n        vec3 {+1.0f, -1.0f, +0.0f},  // bottom right\n        vec3 {-1.0f, +1.0f, +0.0f},  // top    left\n        vec3 {+1.0f, +1.0f, +0.0f}}; // top    right\n    ...\n    static constexpr const char* type_name {\"Quadrilateral\"};\n};\n```\nThe `render` flag, set to `false`, excludes the atom from the being-rendered-club.\n\nBecause Maki allows the user to *jump in time*, it needs to keep track of not only the current, but also any past and future frames.\nThe simplest way of implementing this is to store all atoms for each frame.\nThis results in a multitude of problems:\n\n1. A huge two-dimensional array is required.\n   This can quickly drain all available memory or slow Maki to a crawl.\n2. When the user changes an atom at any frame, this atom and all future incarnations thereof have to be changed.\n3. A wait instruction, which simply leaves the scene as is, would consume as much memory as any other.\n   More frames always mean more memory being consumed, no matter how much is actually happening in them.\n4. Adding a new atom means adding it to all frames.\n\n## Difference Array\nTo solve these problems I'm using a difference array.\nThis difference array can be seen as the numerical derivative of the original array;\ninstead of storing all atoms for every frame, I'm only storing how the atoms change from frame to frame.\n`AtomDiff`s define how an atom has to be altered to cross a frame-border (from one frame to the next, or back from the next to the current).\nAnything from applying a linear transformation, changing the color or just toggling the `render` flag, can be expressed with such an `AtomDiff`.\n\nThis functionality is implemented in the `apply` and `reverse` member functions.\nThese take an atom and apply (or reverse) the changes this `AtomDiff` represents.\nTheir `m_id` member variable can be used to determine the `Atom` this `AtomDiff` should be used for.\n\n```cpp\ntemplate<typename AtomType>\nclass ToggleRenderDiff: public AtomDiff<AtomType> {\npublic:\n    explicit ToggleRenderDiff(uint32_t id)\n        : AtomDiff<AtomType> {id} {}\n\n    virtual void apply(AtomType& atom) const override\n    {\n        atom.render = !atom.render;\n    }\n    virtual void reverse(AtomType& atom) const override\n    {\n        atom.render = !atom.render;\n    }\n};\n```\nTemplating is used to accept any type of `Atom`.\n`AtomDiff`s are always immutable (always declared `const`).\n\nThis solves all of the aforementioned problems:\n\n1. Since `AtomDiff`s only contain the data absolutely needed to apply the represented change, they consume very little memory.\n2. When the user changes an atom at any frame, only one `AtomDiff` has to be created for that frame.\n3. When nothing happens in your scene, no `AtomDiff`s are being added and basically no memory is consumed;\n   you can wait for as long as you like.\n4. Adding a new atom doesn't add another `AtomDiff`.\n   Only all systems using the `AtomDiff`s should be made aware that a new atom exists.\n\nThe actual difference array is implemented in the `AtomDiffLifetime`.\nAn `AtomDiffLifetime` contains one `AtomDiffFrame` for each frame.\n`AtomDiffFrame`s are a container for all `AtomDiff`s belonging to that frame.\nThe `apply` and `reverse` member functions take an entire list of `Atom`s as a parameter.\nThe aforementioned `m_id` member variable is used to apply (or reverse) the correct `AtomDiff`s on the correct `Atom`.\n```cpp\nvoid apply(std::vector<AtomType>& atoms) const\n{\n    for(const AtomDiff<AtomType>* atom_diff: m_atom_diffs) {\n        atom_diff->apply(atoms[atom_diff->get_id()]);\n    }\n}\n```\n\n## Atom Chain\nBeing one of the central classes, an `AtomChain` contains all `Atoms` for one frame `x`.\nThey can be seen as pointing to the frame `x` within the `AtomDiffLifetime`.\nTo stick with the mathematical terminology, think of it as the integral from frame `0` to frame `x`.\nThis \"pointer\" can freely be moved around to represent the requested frame.\nTo achieve this, the underlying `AtomDiff`s owned by the `AtomDiffLifetime` are being used to approach the target frame.\n```cpp\nvoid set_frame(\n    uint32_t frame,\n    const AtomDiffLifetime<AtomType>& atom_diff_lifetime)\n{\n    ...\n    while(m_frame < frame)\n        // adjust m_frame and call atom_diff_lifetime.apply\n        next_frame(atom_diff_lifetime);\n    while(m_frame > frame)\n        prev_frame(atom_diff_lifetime);\n}\n```\nThe difference between an `AtomChain` and an `AtomDiffFrame` is that the `AtomChain` represents the absolute status of a frame.\nThe `AtomDiffFrame`, on the other hand, defines how two consecutive frames differ.\n\nThere are always two atom chains in use for any type, a control and a render atom chain.\n- The render atom chain is needed to render the frame the interactive window requests.\n- To apply any absolute changes at frame `x` the control thread needs to know what the current state of frame `x` is.\n  Otherwise it wouldn't know how to adjust the atoms in frame `x-1` to become the new `x`.\n  Thus the control thread needs its own atom chain.\n\nThe first frame is frame `0`.\nIt cannot display anything as it is used as the foundation for any following frames;\nyou can see it as a defined [constant of integration](https://en.wikipedia.org/wiki/Constant_of_integration).\nOnly subsequent frames can be the target of `AtomDiff`s.\n\n## Chrono Syncs\nOne might wonder what happens when the control atom chain changes a frame that lies before the render atom chain.\nThis is exactly what happened in the [Walkthrough](#walkthrough).\nIn this situation the render atom chain would be outdated, because its *past* changed.\nTo fix this, Maki performs a chrono sync.\n\nThis means that the render atom chain evicts all of it's data and recreates all atoms with default member variables.\nTherefore it points to the 0th frame.\nSince none of the atoms in this frame have been changed, the default atoms currently in the render atom chain are correct—\nthe render thread is synchronised again.\nTo get back to where the render atom chain left off, it can use the already explained `set_frame` member function.\n\n# Templates\nAll functions and classes handling atoms are templated, so that all kinds of atoms can be accepted.\nBut that also means that each `AtomDiffLifetime` can only handle one type of atom.\nTherefore multiple `AtomDiffLifetime`s are required to express the entire breadth of atom types.\n\n## Templated Memory\nTo conveniently access the correct `AtomDiffLifetime`, \"templated memory\" is being used:\n```cpp\nclass AtomDispenser {\n    ...\n    // general declaration\n    template<typename AtomType>\n    AtomDiffLifetime<AtomType>& get_diff_lifetime();\n\n    AtomDiffLifetime<CuboidAtom>        m_cuboid_diff_lifetime {};\n    AtomDiffLifetime<QuadrilateralAtom> m_quadrilateral_diff_lifetime {};\n};\n\n// specializations //\n// for CuboidAtoms\ntemplate<>\ninline AtomDiffLifetime<CuboidAtom>& AtomDispenser::get_diff_lifetime<CuboidAtom>()\n{\n    return m_cuboid_diff_lifetime;\n}\n// for QuadrilateralAtoms\ntemplate<>\ninline AtomDiffLifetime<QuadrilateralAtom>& AtomDispenser::get_diff_lifetime<QuadrilateralAtom>()\n{\n    return m_quadrilateral_diff_lifetime;\n}\n```\nThe function `AtomDiffLifetime<AtomType>& get_diff_lifetime()` is actually nowhere defined.\nOnly the specialized versions can be found, like `AtomDiffLifetime<QuadrilateralAtom>& get_diff_lifetime<QuadrilateralAtom>`.\nAs you can see, the general type `AtomType` has been specialized with `QuadrilateralAtom`.\nThis way the templating system decides which definition should be called, or fails when there is no specialization for the requested type.\n\n## Rendering Atoms\nAn `AtomRenderer` uses the underlying rendering abstraction to actually render an `Atom`.\nThe implementation of such may vary wildly as each `Atom` has a different optimal way of being rendered.\nWhile some may use a common base class (like the `BatchRenderer`) others stand on their own.\n\nThe `AtomRendererRouter` is unfortunately needed to make these different implementations accessible from the templated world of `Atom`s.\n```cpp\ntemplate<typename AtomType>\nstruct AtomRendererRouter {\n    // can't be used unspecialized\n    typedef void type;\n};\n\ntemplate<>\nstruct AtomRendererRouter<CuboidAtom> {\n    typedef CuboidRenderer type;\n};\n\ntemplate<>\nstruct AtomRendererRouter<QuadrilateralAtom> {\n    typedef QuadrilateralRenderer type;\n};\n```\nThis router can be used like this to resolve `Atom` types to their respective renderer:\n```cpp\ntypename AtomRendererRouter<CuboidAtom>::type* m_cuboid_renderer {nullptr};\n```\nBeing converted to this by the compiler:\n```cpp\nCuboidRenderer* m_cuboid_renderer {nullptr};\n```\n(The `{nullptr}` is not necessary but always a nice touch ^^).\n\n## Why Templates?\n<AutoPlayVideo src={fly_around_02} />\n\nWhy not use an arguably much simpler object-oriented approach?\n\nAn `AtomDiff` can be applied to any `Atom` that provides the necessary member functions (an atom that doesn't have a color can't be painted red).\nSo `AtomDiff`s are templated to suit any such `Atom`.\nInstead of using templates, I could have used an abstract `Atom` base class.\n\nThe problem with that lays in the way the `Atom`s are being accessed.\n`Atom`s are currently stored in an `std::vector`, which is the silly C++ way of saying \"dynamic size array\".\nThere is one `std::vector` for each type of `Atom`.\nMemory allocated by an `std::vector` is always contiguous.\nTherefore the atoms lay side by side and the renderer, chewing through all atoms one at a time, gets sped up by the hardware prefetcher.\n\nBut this only works since the compiler knows the size of that type of `Atom`.\nIf I were to use inheritance and a single `std::vector` of type `Atom`, the size of one of these `Atom`s isn't always the same.\nFor example a Cube needs a lot more data than a triangle.\n\nThis can still be done of course.\nThe way to do it is by storing pointers to the actual objects.\nConsequently, that the objects are scattered all over memory and the hardware prefetcher feels an urge to give up.\nIn this case using contiguous memory amounts to a total **performance** increase of 35 to 60 (!!!) percent.\n\nI could have still used multiple `std::vector`s with inheritance.\nBut that means that all `AtomDiff`s and any other objects need to accept abstract types and potentially cast them down into more specific ones.\nThis adds performance overhead, because any one function can't be optimized for one type of atom, and dynamic casting isn't exactly free.\nThe main problem is that calling function discards information, which the called function has to painstakingly recreate.\nTo put it in a nutshell, I'm incredibly **afraid of loosing type information**.\n\n<Spacer />\n\n# Path of an Atom\nLet's wrap things up by looking at the path an atom takes, from the interactive Python shell to the screen.\n\n1. A cuboid gets created from Python using the `add_cuboid_atom` function, which gets redirected to `RenderDriver::add_atom<CuboidAtom>`.\n   This creates a new default constructed `CuboidAtom` in the control and render `AtomChain<CuboidAtom>`s.\n   Python receives an identifier with which it can apply changes to the atom.\n2. Since all default constructed atoms have their `render` flag set to false, our cuboid doesn't get shown.\n   This flag gets checked in the `draw_atom` member functions in the respective `AtomRenderer`.\n3. We perform an operation on the cuboid, namely `show_cuboid_atom`, to start showing the atom in frame `3`.\n   To apply the requested change, the control atom chain is being moved to the 3rd frame.\n4. Now the newly created `ToggleRenderDiff<CuboidAtom>` can be added to the correct `AtomDiffFrame`.\n   Because the control atom chain needs to stay synchronised, the new `AtomDiff` is being applied to it.\n5. The last task the control thread has to perform is to warn the render thread that something got changed.\n   `m_first_outdated_frame` in the `AtomDiffLifetime` gets set to `3-1=2`.\n6. Say our render atom chain is currently representing frame `5`.\n   Because `5>=2` a chrono sync has to be performed, after which the render atom chain is being moved back to frame `5`.\n7. Now the `CuboidRenderer` has a new cube to render, which it does by using the underlying renderer API abstraction.\n\n# Conclusion and Future Plans\nCurrently Maki is a developmental example for the practical use of diff arrays, templates and multi threading.\nAt the time being it isn't a usable program, though that might change in the future.\n\nOne of the biggest areas of development is adding more atoms.\nThis includes bezier curves, spheres and LaTeX rendering.\nAny already implemented atoms can be improved with better shaders.\nAmong other features, these would bring shadows and wireframe rendering to Maki.\nA more complicated aspect is morphing, which is required to smoothly transform atoms into different types.\nAnd lastly the user interface has to be greatly improved.\nThe integration or reimplementation of an already existing graphics library is conceivable.\n\nA major question of debate will concern weather any given feature should be implemented in C++ or Python.\n\n# Appendix\nYou can find Maki's current status on GitHub at [christopher-besch/maki](https://github.com/christopher-besch/maki).\nMaki's version as of this article's writing can be accessed [here](https://github.com/christopher-besch/maki/tree/30f3d5a358e1b89803a534c666318b14138a6756).\nFeel free to leave a star ^^\n\n## Directory Overview\n```\n.\n├── maki\n│   ├── src\n│   │   └── maki.cpp\n│   └── CMakeLists.txt\n├── maki_core\n│   ├── include\n│   │   └── maki.h\n│   ├── res\n│   │   └── shaders\n│   │       ├── cuboid_frag.glsl\n│   │       ├── cuboid_vert.glsl\n│   │       ├── simple_fragment.glsl\n│   │       └── simple_vertex.glsl\n│   ├── src\n│   │   ├── atom\n│   │   │   ├── atoms\n│   │   │   │   ├── cuboid_atom.cpp\n│   │   │   │   ├── cuboid_atom.h\n│   │   │   │   ├── quadrilateral_atom.cpp\n│   │   │   │   └── quadrilateral_atom.h\n│   │   │   ├── renderers\n│   │   │   │   ├── batch_renderer.cpp\n│   │   │   │   ├── batch_renderer.h\n│   │   │   │   ├── cuboid_renderer.cpp\n│   │   │   │   ├── cuboid_renderer.h\n│   │   │   │   ├── quadrilateral_renderer.cpp\n│   │   │   │   └── quadrilateral_renderer.h\n│   │   │   ├── atom_chain.h\n│   │   │   ├── atom_diff_frame.h\n│   │   │   ├── atom_diff.h\n│   │   │   ├── atom_diff_lifetime.h\n│   │   │   ├── atom_dispenser.cpp\n│   │   │   ├── atom_dispenser.h\n│   │   │   ├── atom.h\n│   │   │   └── atom_renderer.h\n│   │   ├── core\n│   │   │   ├── definitions.h\n│   │   │   ├── log.cpp\n│   │   │   ├── log.h\n│   │   │   ├── thread_safety.cpp\n│   │   │   └── thread_safety.h\n│   │   ├── driver\n│   │   │   ├── camera_driver.cpp\n│   │   │   ├── camera_driver.h\n│   │   │   ├── interface.h\n│   │   │   ├── render_driver_control.cpp\n│   │   │   ├── render_driver.h\n│   │   │   └── render_driver_render.cpp\n│   │   ├── platform\n│   │   │   ├── glfw\n│   │   │   │   └── glfw_window.cpp\n│   │   │   ├── enums.h\n│   │   │   ├── event.h\n│   │   │   ├── window.cpp\n│   │   │   └── window.h\n│   │   ├── renderer\n│   │   │   ├── opengl\n│   │   │   │   ├── opengl_buffer.cpp\n│   │   │   │   ├── opengl_buffer.h\n│   │   │   │   ├── opengl_renderer.cpp\n│   │   │   │   ├── opengl_renderer.h\n│   │   │   │   ├── opengl_shader.cpp\n│   │   │   │   ├── opengl_shader.h\n│   │   │   │   ├── opengl_stringifier.cpp\n│   │   │   │   ├── opengl_stringifier.h\n│   │   │   │   ├── opengl_types.h\n│   │   │   │   ├── opengl_vertex_array.cpp\n│   │   │   │   └── opengl_vertex_array.h\n│   │   │   ├── buffer.cpp\n│   │   │   ├── buffer.h\n│   │   │   ├── camera.cpp\n│   │   │   ├── camera.h\n│   │   │   ├── renderer.cpp\n│   │   │   ├── renderer.h\n│   │   │   ├── shader.cpp\n│   │   │   ├── shader.h\n│   │   │   ├── types.h\n│   │   │   ├── vertex_array.cpp\n│   │   │   └── vertex_array.h\n│   │   ├── pch.cpp\n│   │   └── pch.h\n│   └── CMakeLists.txt\n├── stub\n│   ├── src\n│   │   └── main.cpp\n│   └── CMakeLists.txt\n└── CMakeLists.txt\n```\nCreated with\n```bash\ntree --dirsfirst . -I 'vendor|build|pretty_bugs|block.txt|imgui.ini|LICENSE|maki.cpython-310-x86_64-linux-gnu.so|maki_showcase.ipynb|README.md'\n```\n","frontmatter":{"date":"Sunday, 6th February, 2022","title":"Maki, Atoms and Time Travel","description":" Maki showcases how a program for interactive and programmatic animation development can be implemented.\nIts programmatic approach provides the precision technical concepts require, while its interactivity and real-time updates avoid a disconnect between input and output. ","banner":"/social_banner/maki_atoms_and_time_travel.png","title_banner":null,"title_banner_horizontal_position":null,"title_banner_vertical_position":null,"version":"1.0.2"}}},"pageContext":{"id":"439bcd05-da4f-5d27-bcc6-1ab6d3b3addf","frontmatter":{"type":"article","title":"Maki, Atoms and Time Travel","description":" Maki showcases how a program for interactive and programmatic animation development can be implemented.\nIts programmatic approach provides the precision technical concepts require, while its interactivity and real-time updates avoid a disconnect between input and output. ","banner":"/social_banner/maki_atoms_and_time_travel.png","thumb":"../../../static/social_banner/maki_atoms_and_time_travel.png","slug":"maki_atoms_and_time_travel","date":"2022-02-06T00:00:00.000Z","listed":true,"version":"1.0.2"}}},"staticQueryHashes":["1995789189","2480137602","475732191"],"slicesMap":{}}