<!DOCTYPE html><html><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Maki, Atoms and Time Travel</title><meta name="description" content=" Maki showcases how a program for interactive and programmatic animation development can be implemented.
Its programmatic approach provides the precision technical concepts require, while its interactivity and real-time updates avoid a disconnect between input and output. "/><link rel="icon" type="image/png" sizes="48x48" href="/favicon.png"/><link rel="stylesheet" type="text/css" href="/styles/always.css"/><link rel="stylesheet" type="text/css" href="/styles/article.css"/></head><body><div class="layout_navbar"><a class="layout_navbar_left" href="/"><h1>Christopher Besch</h1><h2>Developer•Writer•Photographer</h2></a><div class="layout_navbar_right"><input id="layout_navbar_toggle" type="checkbox"/><label for="layout_navbar_toggle" class="layout_navbar_hamburger"><div></div><div></div><div></div></label><div class="layout_nav_links"><a href="/articles">Articles</a><a href="/photography">Photos</a><a href="/projects">Projects</a><a href="/talks">Talks</a><a href="/articles/bookmarks">Bookmarks</a><a href="/about">About</a></div></div></div><div class="layout_transient_space"><div class="layout_nav_links"><a href="/articles">Articles</a><a href="/photography">Photos</a><a href="/projects">Projects</a><a href="/talks">Talks</a><a href="/articles/bookmarks">Bookmarks</a><a href="/about">About</a></div><p>This is a transient space.</p></div><div class="layout_content_container"><div class="layout_content"><div class="title_in_text"><h1>Maki, Atoms and Time Travel</h1><hr/><h2>Sunday, 6th February, 2022</h2></div><div class="article_page_markdown"><div class="markdown_body"><p>To create animations for technical concepts, one is advised to use graphics software with a programmatic approach.
While these provide the required precision, they suffer from an inherent disconnect between input and output.
WYSIWYG programs avoid this detachment with interactivity at the cost of precision.</p>
<p>The purpose of this article is to outline how a program for interactive and programmatic animation development can be implemented.
To experiment with different technologies and programming paradigms, I created a developmental implementation called Maki.
This article outlines Maki&#x27;s design decisions and discusses planned future development.</p>
<h3 id="table-of-contents"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#table-of-contents"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of Contents</h3>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/d7c678b3e40f17b6c61552e79fe65816.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<ul><li><a href="#maki">Maki</a><ul><li><a href="#walkthrough">Walkthrough</a></li></ul></li><li><a href="#clear-ownership">Clear Ownership</a></li><li><a href="#renderer-abstraction">Renderer Abstraction</a></li><li><a href="#multi-threading">Multi Threading</a></li><li><a href="#atoms">Atoms</a><ul><li><a href="#difference-array">Difference Array</a></li><li><a href="#atom-chain">Atom Chain</a></li><li><a href="#chrono-syncs">Chrono Syncs</a></li></ul></li><li><a href="#templates">Templates</a><ul><li><a href="#templated-memory">Templated Memory</a></li><li><a href="#rendering-atoms">Rendering Atoms</a></li><li><a href="#why-templates">Why Templates?</a></li></ul></li><li><a href="#path-of-an-atom">Path of an Atom</a></li><li><a href="#conclusion-and-future-plans">Conclusion and Future Plans</a></li><li><a href="#appendix">Appendix</a></li></ul>
<h1 id="maki"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#maki"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maki</h1>
<ul>
<li><strong>Extensibility</strong>,</li>
<li><strong>performance</strong>,</li>
<li><strong>ease of use</strong>,</li>
<li><strong>strict type and thread safety</strong>,</li>
<li><strong>clear ownership</strong> and the</li>
<li><strong>fear of loosing (type) information</strong> form Maki&#x27;s main ideals.</li>
</ul>
<p>I chose C++ because it enforces <strong>strict rules</strong> and offers handy containers, algorithms and many light-weight abstractions, aiding in the development of a complex system, without compromising on <strong>performance</strong>.</p>
<p>The goal of <a href="https://github.com/christopher-besch/maki">Maki</a> is to allow the user to create 3D animations using Python;
while the user is constructing their animation in an interactive shell, Maki shows the current status of the scene in a separate window.
Here the user is able to freely move the camera.
In addition to spacial movement, Maki provides the ability to <em>jump in time</em>;
The user can decide which frame of the animation should be played.</p>
<p>This allows an <strong>easy to use</strong> workflow, minimizing the time between defining animations and playing with the results.</p>
<h2 id="walkthrough"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#walkthrough"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Walkthrough</h2>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/f69f679fd352afd655b60454fc2f4d78.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>To start working with Maki, one has to initialize it.
This defines the rendering API to be used and creates a window of the specified size.</p>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/36acfa77abafe614545cdb2d8e39865f.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>Once that is done, you can create an atom.
This call to <code>add_cuboid_atom</code> returns a handle to the cuboid.
But you will see...that you don&#x27;t see anything.</p>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/1821eced5b6c5c7bae2ecc1d0e69838f.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>That&#x27;s because you&#x27;ve only created the atom;
you still have to tell Maki to actually render it.
This call to <code>show_cuboid_atom</code> orders Maki to start showing the atom at frame <code>1</code>.</p>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/8b44b98b1541503fa5457d2bb6af019d.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>We can also change the colour.
Each call again needs to know what frame it should be applied to.</p>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/9929e46980e982ee1bae69eeffd4c108.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>Our cube can also be moved.
But Maki currently only supports instant movement—&quot;teleporting&quot; from one frame to the next.</p>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/5e15d3a047e16c1bf629f00090b2f94c.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>Smooth transitions have to be implemented on the Python side.
This quick implementation performs just that; it smoothly shifts the cube from frame <code>60</code> to frame <code>200</code>.</p>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/513a9fe414ca14c05b73ddf313b59fe3.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>As you can see, Maki currently shows the 199th frame.
But now I&#x27;m applying another downward translation from frame <code>5</code> to <code>50</code>.
This downward shift lies in the past, so we expect the cube to be in a lower position in the present.
And that&#x27;s exactly what we see:
The moment the shift is being applied, Maki performs a <a href="#chrono-sync">Chrono Sync</a> and the cube changes it&#x27;s position.
The past was altered, and we see the repercussions in the present.</p>
<blockquote><center><em>&quot;<!-- -->The past was erased, the erasure was forgotten, the lie became truth.<!-- -->&quot;</em>  —<!-- -->1984</center></blockquote>
<div class="markdown_spacer"></div>
<h1 id="clear-ownership"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#clear-ownership"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clear Ownership</h1>
<p>Shared ownership, where multiple classes own a single resource, are convenient to implement;
<em>everything has access to everything</em>, so the optimum of possibilities has been achieved.
But those programs, in which <em>everything owns everything</em> and <em>everything calls everything</em> are very difficult to reason about and tend to be less performant.</p>
<p>When instead every resource is owned by only one object, that object&#x27;s constructor acquires the resources and the destructor subsequently frees them.
This programming technique (called <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a> by the C++ committee for silly names) leaves no need for any garbage collection.</p>
<p>But in some situations the same resource has to be <em>used</em> by multiple objects.
With an emphasis on <em>used</em>;
these situations don&#x27;t necessarily warrant the use of shared ownership.
Instead the resource can be <em>borrowed</em>.
For example, without going into detail of what these classes actually do:
A <code>RenderDriver</code> owns a <code>Renderer</code> and an <code>AtomDispenser</code>.
The <code>AtomDispenser</code> needs the <code>Renderer</code> to perform its task, so it <em>borrows</em> it from the <code>RenderDriver</code>.
And because both the <code>AtomDispenser</code> and the <code>Renderer</code> are owned by the same <code>RenderDriver</code>, the <code>AtomDispenser</code> can rest assured that all its resources are (still) available.</p>
<p>This member function lends the <code>Renderer</code> to an <code>AtomDispenser</code>:</p>
<pre><code class="language-cpp"><span class="pl-k">void</span> <span class="pl-en">AtomDispenser::create_all_atom_renderers</span>(Renderer* renderer)
{
    ...
}
</code></pre>
<p>But not having to garbage collect isn&#x27;t the only performance advantage.
A <strong>clear ownership model</strong> also bestows a definitive purpose on each function and object.
Objects are restricted to the resources they need to fulfill their task:
Anything they don&#x27;t need, they don&#x27;t have access to.
This reduces side-effects and consequently improves debuggability.</p>
<p>Knowing in which context what data is being used, allows the programmer to optimize memory accesses for just these contexts.</p>
<blockquote><center><em>&quot;<!-- -->Software does not run in a magic fairy aether powered by the fever dreams of CS PhDs.<!-- -->&quot;</em>  —<!-- -->Mike Acton</center></blockquote>
<p>Software runs on hardware, hardware that has certain tastes.
So if you intend to write fast software, you should base your data layout on the silicon it&#x27;s supposed to run on.
Only because two concepts have something in common in the mental model of yours, doesn&#x27;t mean their data representation has to have anything to do with each other.
In fact they may vary wildly.
That&#x27;s why, what a concept&#x27;s implementation should be based on, is the hardware in use, not the mental model of any programmer.</p>
<p>Therefore a <strong>clear ownership</strong> model is easier to reason about and the foundation for high performing software.
Memory layout will also play a major role in <a href="#why-templates">Why Templates?</a>.</p>
<h1 id="renderer-abstraction"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#renderer-abstraction"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renderer Abstraction</h1>
<p>Even though Maki is currently using OpenGL only, different rendering APIs (like Vulcan, Metal or DirectX) can easily be added.
To achieve this many low-lever rendering concepts are implemented using abstract classes (e.g. <code>Shader</code>, <code>Renderer</code> and <code>VertexBuffer</code>).
The actual API specific implementations (e.g. <code>OpenGLShader</code>) can be found in a subdirectory:</p>
<pre><code>.
├── opengl
│   ├── opengl_buffer.cpp
│   ├── opengl_buffer.h
│   ├── opengl_renderer.cpp
│   ├── opengl_renderer.h
│   ├── ...
├── buffer.cpp
├── buffer.h
├── renderer.cpp
├── renderer.h
├── ...
</code></pre>
<p>The abstract classes define the static function <code>create</code> to create an instance of the appropriate class:</p>
<pre><code class="language-cpp">IndexBuffer* <span class="pl-en">IndexBuffer::create</span>(<span class="pl-c1">uint32_t</span> count, <span class="pl-k">const</span> <span class="pl-c1">uint32_t</span>* indices)
{
    <span class="pl-k">switch</span>(<span class="pl-c1">Renderer::get_renderer_impl</span>()) {
    ...
    <span class="pl-k">case</span> Renderer::Implementation::opengl:
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-c1">OpenGLIndexBuffer</span>(count, indices);
    <span class="pl-k">default</span>:
        <span class="pl-c1">MAKI_RAISE_CRITICAL</span>(<span class="pl-s"><span class="pl-pds">&quot;</span>The requested renderer implementation is not supported.<span class="pl-pds">&quot;</span></span>);
        <span class="pl-k">return</span> <span class="pl-c1">nullptr</span>;
    }
}
</code></pre>
<p>The static function <code>Renderer::set_renderer_impl</code> is used to globally define the renderer API at Maki&#x27;s boot up.</p>
<p>This decision, which renderer API should be used, is performed at runtime.
That way the user can decide which implementation to use:
Even so you&#x27;re on Windows, you might want to use OpenGL instead of DirectX because you have custom shaders written in GLSL.</p>
<p>The situation is different for the platform, i.e. the window handling mechanism, which is selected based on the type of target system.
GLFW can be used on Linux, Windows and the MacOS;
WebAssembly might need something else.
The crucial difference to the renderer API is that the decision, which platform is to be used, can be made at compile time.
By using preprocessor statements to only compile the required platform, the switch statement can be avoided and some runtime overhead removed.</p>
<pre><code class="language-cpp">#<span class="pl-k">if</span> PROJECT == glfw
    GLFWwindow* m_handle {<span class="pl-c1">nullptr</span>};
#<span class="pl-k">endif</span>
</code></pre>
<p>This macro has to be set using the <code>-Dplatform=glfw</code> flag at compilation.</p>
<p>As you can see, <strong>extensibility</strong> lies at the heart of Maki.</p>
<h1 id="multi-threading"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#multi-threading"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multi Threading</h1>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/ed91c47706e6cc159e99ff6f4a0eda40.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>There are always two things happening concurrently:</p>
<ol>
<li>accepting new atoms or changing existing ones and</li>
<li>rendering the scene or handling user interaction.</li>
</ol>
<p>This is why it makes sense to use two threads, a control and a render thread.
Since OpenGL doesn&#x27;t allow multiple threads to use the same context, only the render thread is allowed to perform render calls.
The control thread on the other hand is the only one Python can directly interface with.
Consequently, data has to be safely exchanged between the two threads.
In addition to that, each thread should under no circumstances be allowed to perform actions outside of its jurisdiction.</p>
<p>When Maki wakes up, the first order of business is to initialize the (main) control thread, after which the render thread is to be created.
This initialization includes calling <code>SET_THREAD_TYPE_CONTROL()</code> and <code>SET_THREAD_TYPE_RENDER()</code> from the respective threads.
These preprocessor macros define a thread local variable.
Since each thread has it&#x27;s own thread local variables, they can be used to deduce the type of any thread.</p>
<p>Every function can then be equipped with a call to <code>MAKI_ASSERT_CTRL_THREAD()</code> or <code>MAKI_ASSERT_RNDR_THREAD()</code>, which asserts that the correct thread is being used.
Since these checks are being removed for <code>Release</code> mode and are only included in <code>Debug</code> builds (which can be specified using the <code>-DCMAKE_BUILD_TYPE=Release</code> flag) there is no runtime overhead.</p>
<pre><code class="language-cpp">#<span class="pl-k">ifndef</span> NDEBUG
...
#<span class="pl-k">define</span> <span class="pl-en">MAKI_ASSERT_CTRL_THREAD</span>()                              \
    <span class="pl-en">MAKI_ASSERT_CRITICAL</span>(g_thread_type == ThreadType::control, \
                         <span class="pl-s"><span class="pl-pds">&quot;</span>This function can only be called from the control thread.<span class="pl-pds">&quot;</span></span>)
#<span class="pl-k">define</span> <span class="pl-en">MAKI_ASSERT_RNDR_THREAD</span>()                             \
    <span class="pl-en">MAKI_ASSERT_CRITICAL</span>(g_thread_type == ThreadType::render, \
                         <span class="pl-s"><span class="pl-pds">&quot;</span>This function can only be called from the render thread.<span class="pl-pds">&quot;</span></span>)
#<span class="pl-k">else</span>
...
<span class="pl-c">// don&#x27;t do anything in release mode</span>
#<span class="pl-k">define</span> <span class="pl-en">MAKI_ASSERT_CTRL_THREAD</span>()
#<span class="pl-k">define</span> <span class="pl-en">MAKI_ASSERT_RNDR_THREAD</span>()

#<span class="pl-k">endif</span>
</code></pre>
<p>To prevent race conditions (uncontrolled, concurrent access to the same resource) mutexes are being used.
These &quot;mutual exclusion objects&quot; allow the locking of a resource for the duration of its use.
In addition to this locking operation being a rather expensive one, all other threads in need of that resource are being stalled.
Therefore the use of mutexes ought to be minimized.</p>
<p>These two precautions, preventing the threads from running incorrect functions and accessing resources at the same time, form the basis for Maki&#x27;s <strong>thread safety</strong>.</p>
<div class="markdown_spacer"></div>
<h1 id="atoms"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#atoms"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Atoms</h1>
<p>Just like how real atoms were thought to be the indivisible unit of the universe, atoms are the smallest renderable unit in Maki.
A collection of them form a frame, multiple of which form an entire scene, which can be rendered to a video file.</p>
<p>An <code>Atom</code> stores all the data required to render that atom.
This mainly includes vertex data, like position or colour.</p>
<pre><code class="language-cpp"><span class="pl-k">struct</span> <span class="pl-en">Atom</span> {
    <span class="pl-k">bool</span> render {<span class="pl-c1">false</span>};

    <span class="pl-c">// to be defined by implementation:</span>
    <span class="pl-c">// static constexpr const char* type_name {&quot;Atom&quot;};</span>
};

<span class="pl-k">struct</span> <span class="pl-en">QuadrilateralAtom</span>: <span class="pl-k">public</span> <span class="pl-en">Atom</span> {
    std::array&lt;vec3, <span class="pl-c1">4</span>&gt; ver_pos {
        vec3 {-<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, -<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, +<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>},  <span class="pl-c">// bottom left</span>
        vec3 {+<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, -<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, +<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>},  <span class="pl-c">// bottom right</span>
        vec3 {-<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, +<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, +<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>},  <span class="pl-c">// top    left</span>
        vec3 {+<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, +<span class="pl-c1">1</span>.<span class="pl-c1">0f</span>, +<span class="pl-c1">0</span>.<span class="pl-c1">0f</span>}}; <span class="pl-c">// top    right</span>
    ...
    <span class="pl-k">static</span> <span class="pl-k">constexpr</span> <span class="pl-k">const</span> <span class="pl-k">char</span>* type_name {<span class="pl-s"><span class="pl-pds">&quot;</span>Quadrilateral<span class="pl-pds">&quot;</span></span>};
};
</code></pre>
<p>The <code>render</code> flag, set to <code>false</code>, excludes the atom from the being-rendered-club.</p>
<p>Because Maki allows the user to <em>jump in time</em>, it needs to keep track of not only the current, but also any past and future frames.
The simplest way of implementing this is to store all atoms for each frame.
This results in a multitude of problems:</p>
<ol>
<li>A huge two-dimensional array is required.
This can quickly drain all available memory or slow Maki to a crawl.</li>
<li>When the user changes an atom at any frame, this atom and all future incarnations thereof have to be changed.</li>
<li>A wait instruction, which simply leaves the scene as is, would consume as much memory as any other.
More frames always mean more memory being consumed, no matter how much is actually happening in them.</li>
<li>Adding a new atom means adding it to all frames.</li>
</ol>
<h2 id="difference-array"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#difference-array"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Difference Array</h2>
<p>To solve these problems I&#x27;m using a difference array.
This difference array can be seen as the numerical derivative of the original array;
instead of storing all atoms for every frame, I&#x27;m only storing how the atoms change from frame to frame.
<code>AtomDiff</code>s define how an atom has to be altered to cross a frame-border (from one frame to the next, or back from the next to the current).
Anything from applying a linear transformation, changing the color or just toggling the <code>render</code> flag, can be expressed with such an <code>AtomDiff</code>.</p>
<p>This functionality is implemented in the <code>apply</code> and <code>reverse</code> member functions.
These take an atom and apply (or reverse) the changes this <code>AtomDiff</code> represents.
Their <code>m_id</code> member variable can be used to determine the <code>Atom</code> this <code>AtomDiff</code> should be used for.</p>
<pre><code class="language-cpp"><span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> AtomType&gt;
<span class="pl-k">class</span> <span class="pl-en">ToggleRenderDiff</span>: <span class="pl-k">public</span> <span class="pl-en">AtomDiff</span>&lt;AtomType&gt; {
<span class="pl-k">public:</span>
    <span class="pl-k">explicit</span> <span class="pl-en">ToggleRenderDiff</span>(<span class="pl-c1">uint32_t</span> id)
        : AtomDiff&lt;AtomType&gt; {id} {}

    <span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">apply</span>(AtomType&amp; atom) <span class="pl-k">const</span> <span class="pl-k">override</span>
    {
        atom.<span class="pl-smi">render</span> = !atom.<span class="pl-smi">render</span>;
    }
    <span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">reverse</span>(AtomType&amp; atom) <span class="pl-k">const</span> <span class="pl-k">override</span>
    {
        atom.<span class="pl-smi">render</span> = !atom.<span class="pl-smi">render</span>;
    }
};
</code></pre>
<p>Templating is used to accept any type of <code>Atom</code>.
<code>AtomDiff</code>s are always immutable (always declared <code>const</code>).</p>
<p>This solves all of the aforementioned problems:</p>
<ol>
<li>Since <code>AtomDiff</code>s only contain the data absolutely needed to apply the represented change, they consume very little memory.</li>
<li>When the user changes an atom at any frame, only one <code>AtomDiff</code> has to be created for that frame.</li>
<li>When nothing happens in your scene, no <code>AtomDiff</code>s are being added and basically no memory is consumed;
you can wait for as long as you like.</li>
<li>Adding a new atom doesn&#x27;t add another <code>AtomDiff</code>.
Only all systems using the <code>AtomDiff</code>s should be made aware that a new atom exists.</li>
</ol>
<p>The actual difference array is implemented in the <code>AtomDiffLifetime</code>.
An <code>AtomDiffLifetime</code> contains one <code>AtomDiffFrame</code> for each frame.
<code>AtomDiffFrame</code>s are a container for all <code>AtomDiff</code>s belonging to that frame.
The <code>apply</code> and <code>reverse</code> member functions take an entire list of <code>Atom</code>s as a parameter.
The aforementioned <code>m_id</code> member variable is used to apply (or reverse) the correct <code>AtomDiff</code>s on the correct <code>Atom</code>.</p>
<pre><code class="language-cpp"><span class="pl-k">void</span> <span class="pl-en">apply</span>(std::vector&lt;AtomType&gt;&amp; atoms) <span class="pl-k">const</span>
{
    <span class="pl-k">for</span>(<span class="pl-k">const</span> AtomDiff&lt;AtomType&gt;* atom_diff: m_atom_diffs) {
        atom_diff-&gt;<span class="pl-c1">apply</span>(atoms[atom_diff-&gt;<span class="pl-c1">get_id</span>()]);
    }
}
</code></pre>
<h2 id="atom-chain"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#atom-chain"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Atom Chain</h2>
<p>Being one of the central classes, an <code>AtomChain</code> contains all <code>Atoms</code> for one frame <code>x</code>.
They can be seen as pointing to the frame <code>x</code> within the <code>AtomDiffLifetime</code>.
To stick with the mathematical terminology, think of it as the integral from frame <code>0</code> to frame <code>x</code>.
This &quot;pointer&quot; can freely be moved around to represent the requested frame.
To achieve this, the underlying <code>AtomDiff</code>s owned by the <code>AtomDiffLifetime</code> are being used to approach the target frame.</p>
<pre><code class="language-cpp"><span class="pl-k">void</span> <span class="pl-en">set_frame</span>(
    <span class="pl-c1">uint32_t</span> frame,
    <span class="pl-k">const</span> AtomDiffLifetime&lt;AtomType&gt;&amp; atom_diff_lifetime)
{
    ...
    <span class="pl-k">while</span>(m_frame &lt; frame)
        <span class="pl-c">// adjust m_frame and call atom_diff_lifetime.apply</span>
        <span class="pl-c1">next_frame</span>(atom_diff_lifetime);
    <span class="pl-k">while</span>(m_frame &gt; frame)
        <span class="pl-c1">prev_frame</span>(atom_diff_lifetime);
}
</code></pre>
<p>The difference between an <code>AtomChain</code> and an <code>AtomDiffFrame</code> is that the <code>AtomChain</code> represents the absolute status of a frame.
The <code>AtomDiffFrame</code>, on the other hand, defines how two consecutive frames differ.</p>
<p>There are always two atom chains in use for any type, a control and a render atom chain.</p>
<ul>
<li>The render atom chain is needed to render the frame the interactive window requests.</li>
<li>To apply any absolute changes at frame <code>x</code> the control thread needs to know what the current state of frame <code>x</code> is.
Otherwise it wouldn&#x27;t know how to adjust the atoms in frame <code>x-1</code> to become the new <code>x</code>.
Thus the control thread needs its own atom chain.</li>
</ul>
<p>The first frame is frame <code>0</code>.
It cannot display anything as it is used as the foundation for any following frames;
you can see it as a defined <a href="https://en.wikipedia.org/wiki/Constant_of_integration">constant of integration</a>.
Only subsequent frames can be the target of <code>AtomDiff</code>s.</p>
<h2 id="chrono-syncs"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#chrono-syncs"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chrono Syncs</h2>
<p>One might wonder what happens when the control atom chain changes a frame that lies before the render atom chain.
This is exactly what happened in the <a href="#walkthrough">Walkthrough</a>.
In this situation the render atom chain would be outdated, because its <em>past</em> changed.
To fix this, Maki performs a chrono sync.</p>
<p>This means that the render atom chain evicts all of it&#x27;s data and recreates all atoms with default member variables.
Therefore it points to the 0th frame.
Since none of the atoms in this frame have been changed, the default atoms currently in the render atom chain are correct—
the render thread is synchronised again.
To get back to where the render atom chain left off, it can use the already explained <code>set_frame</code> member function.</p>
<h1 id="templates"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#templates"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Templates</h1>
<p>All functions and classes handling atoms are templated, so that all kinds of atoms can be accepted.
But that also means that each <code>AtomDiffLifetime</code> can only handle one type of atom.
Therefore multiple <code>AtomDiffLifetime</code>s are required to express the entire breadth of atom types.</p>
<h2 id="templated-memory"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#templated-memory"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Templated Memory</h2>
<p>To conveniently access the correct <code>AtomDiffLifetime</code>, &quot;templated memory&quot; is being used:</p>
<pre><code class="language-cpp"><span class="pl-k">class</span> <span class="pl-en">AtomDispenser</span> {
    ...
    <span class="pl-c">// general declaration</span>
    <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> AtomType&gt;
    AtomDiffLifetime&lt;AtomType&gt;&amp; <span class="pl-en">get_diff_lifetime</span>();

    AtomDiffLifetime&lt;CuboidAtom&gt;        m_cuboid_diff_lifetime {};
    AtomDiffLifetime&lt;QuadrilateralAtom&gt; m_quadrilateral_diff_lifetime {};
};

<span class="pl-c">// specializations //</span>
<span class="pl-c">// for CuboidAtoms</span>
<span class="pl-k">template</span>&lt;&gt;
<span class="pl-k">inline</span> AtomDiffLifetime&lt;CuboidAtom&gt;&amp; AtomDispenser::get_diff_lifetime&lt;CuboidAtom&gt;()
{
    <span class="pl-k">return</span> m_cuboid_diff_lifetime;
}
<span class="pl-c">// for QuadrilateralAtoms</span>
<span class="pl-k">template</span>&lt;&gt;
<span class="pl-k">inline</span> AtomDiffLifetime&lt;QuadrilateralAtom&gt;&amp; AtomDispenser::get_diff_lifetime&lt;QuadrilateralAtom&gt;()
{
    <span class="pl-k">return</span> m_quadrilateral_diff_lifetime;
}
</code></pre>
<p>The function <code>AtomDiffLifetime&lt;AtomType&gt;&amp; get_diff_lifetime()</code> is actually nowhere defined.
Only the specialized versions can be found, like <code>AtomDiffLifetime&lt;QuadrilateralAtom&gt;&amp; get_diff_lifetime&lt;QuadrilateralAtom&gt;</code>.
As you can see, the general type <code>AtomType</code> has been specialized with <code>QuadrilateralAtom</code>.
This way the templating system decides which definition should be called, or fails when there is no specialization for the requested type.</p>
<h2 id="rendering-atoms"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#rendering-atoms"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendering Atoms</h2>
<p>An <code>AtomRenderer</code> uses the underlying rendering abstraction to actually render an <code>Atom</code>.
The implementation of such may vary wildly as each <code>Atom</code> has a different optimal way of being rendered.
While some may use a common base class (like the <code>BatchRenderer</code>) others stand on their own.</p>
<p>The <code>AtomRendererRouter</code> is unfortunately needed to make these different implementations accessible from the templated world of <code>Atom</code>s.</p>
<pre><code class="language-cpp"><span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> AtomType&gt;
<span class="pl-k">struct</span> <span class="pl-en">AtomRendererRouter</span> {
    <span class="pl-c">// can&#x27;t be used unspecialized</span>
    <span class="pl-k">typedef</span> <span class="pl-k">void</span> type;
};

<span class="pl-k">template</span>&lt;&gt;
<span class="pl-k">struct</span> <span class="pl-en">AtomRendererRouter</span>&lt;CuboidAtom&gt; {
    <span class="pl-k">typedef</span> CuboidRenderer type;
};

<span class="pl-k">template</span>&lt;&gt;
<span class="pl-k">struct</span> <span class="pl-en">AtomRendererRouter</span>&lt;QuadrilateralAtom&gt; {
    <span class="pl-k">typedef</span> QuadrilateralRenderer type;
};
</code></pre>
<p>This router can be used like this to resolve <code>Atom</code> types to their respective renderer:</p>
<pre><code class="language-cpp"><span class="pl-k">typename</span> AtomRendererRouter&lt;CuboidAtom&gt;::type* m_cuboid_renderer {<span class="pl-c1">nullptr</span>};
</code></pre>
<p>Being converted to this by the compiler:</p>
<pre><code class="language-cpp">CuboidRenderer* m_cuboid_renderer {<span class="pl-c1">nullptr</span>};
</code></pre>
<p>(The <code>{nullptr}</code> is not necessary but always a nice touch ^^).</p>
<h2 id="why-templates"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#why-templates"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why Templates?</h2>
<div class="half_element_wrapper"><div class="half_element_before"></div><div class="half_element_element"><p class="half_video_removed_warn">[video removed from print]</p><video class="half_video_video" controls="" loop="" muted="" autoPlay="" playsInline="" width="1920" height="1080"><source src="/videos/b7d1714e4d5cb995aee62ae843c276a5.mp4" type="video/mp4"/></video></div><div class="half_element_after"></div></div>
<p>Why not use an arguably much simpler object-oriented approach?</p>
<p>An <code>AtomDiff</code> can be applied to any <code>Atom</code> that provides the necessary member functions (an atom that doesn&#x27;t have a color can&#x27;t be painted red).
So <code>AtomDiff</code>s are templated to suit any such <code>Atom</code>.
Instead of using templates, I could have used an abstract <code>Atom</code> base class.</p>
<p>The problem with that lays in the way the <code>Atom</code>s are being accessed.
<code>Atom</code>s are currently stored in an <code>std::vector</code>, which is the silly C++ way of saying &quot;dynamic size array&quot;.
There is one <code>std::vector</code> for each type of <code>Atom</code>.
Memory allocated by an <code>std::vector</code> is always contiguous.
Therefore the atoms lay side by side and the renderer, chewing through all atoms one at a time, gets sped up by the hardware prefetcher.</p>
<p>But this only works since the compiler knows the size of that type of <code>Atom</code>.
If I were to use inheritance and a single <code>std::vector</code> of type <code>Atom</code>, the size of one of these <code>Atom</code>s isn&#x27;t always the same.
For example a Cube needs a lot more data than a triangle.</p>
<p>This can still be done of course.
The way to do it is by storing pointers to the actual objects.
Consequently, that the objects are scattered all over memory and the hardware prefetcher feels an urge to give up.
In this case using contiguous memory amounts to a total <strong>performance</strong> increase of 35 to 60 (!!!) percent.</p>
<p>I could have still used multiple <code>std::vector</code>s with inheritance.
But that means that all <code>AtomDiff</code>s and any other objects need to accept abstract types and potentially cast them down into more specific ones.
This adds performance overhead, because any one function can&#x27;t be optimized for one type of atom, and dynamic casting isn&#x27;t exactly free.
The main problem is that calling function discards information, which the called function has to painstakingly recreate.
To put it in a nutshell, I&#x27;m incredibly <strong>afraid of loosing type information</strong>.</p>
<div class="markdown_spacer"></div>
<h1 id="path-of-an-atom"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#path-of-an-atom"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Path of an Atom</h1>
<p>Let&#x27;s wrap things up by looking at the path an atom takes, from the interactive Python shell to the screen.</p>
<ol>
<li>A cuboid gets created from Python using the <code>add_cuboid_atom</code> function, which gets redirected to <code>RenderDriver::add_atom&lt;CuboidAtom&gt;</code>.
This creates a new default constructed <code>CuboidAtom</code> in the control and render <code>AtomChain&lt;CuboidAtom&gt;</code>s.
Python receives an identifier with which it can apply changes to the atom.</li>
<li>Since all default constructed atoms have their <code>render</code> flag set to false, our cuboid doesn&#x27;t get shown.
This flag gets checked in the <code>draw_atom</code> member functions in the respective <code>AtomRenderer</code>.</li>
<li>We perform an operation on the cuboid, namely <code>show_cuboid_atom</code>, to start showing the atom in frame <code>3</code>.
To apply the requested change, the control atom chain is being moved to the 3rd frame.</li>
<li>Now the newly created <code>ToggleRenderDiff&lt;CuboidAtom&gt;</code> can be added to the correct <code>AtomDiffFrame</code>.
Because the control atom chain needs to stay synchronised, the new <code>AtomDiff</code> is being applied to it.</li>
<li>The last task the control thread has to perform is to warn the render thread that something got changed.
<code>m_first_outdated_frame</code> in the <code>AtomDiffLifetime</code> gets set to <code>3-1=2</code>.</li>
<li>Say our render atom chain is currently representing frame <code>5</code>.
Because <code>5&gt;=2</code> a chrono sync has to be performed, after which the render atom chain is being moved back to frame <code>5</code>.</li>
<li>Now the <code>CuboidRenderer</code> has a new cube to render, which it does by using the underlying renderer API abstraction.</li>
</ol>
<h1 id="conclusion-and-future-plans"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#conclusion-and-future-plans"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion and Future Plans</h1>
<p>Currently Maki is a developmental example for the practical use of diff arrays, templates and multi threading.
At the time being it isn&#x27;t a usable program, though that might change in the future.</p>
<p>One of the biggest areas of development is adding more atoms.
This includes bezier curves, spheres and LaTeX rendering.
Any already implemented atoms can be improved with better shaders.
Among other features, these would bring shadows and wireframe rendering to Maki.
A more complicated aspect is morphing, which is required to smoothly transform atoms into different types.
And lastly the user interface has to be greatly improved.
The integration or reimplementation of an already existing graphics library is conceivable.</p>
<p>A major question of debate will concern weather any given feature should be implemented in C++ or Python.</p>
<h1 id="appendix"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#appendix"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appendix</h1>
<p>You can find Maki&#x27;s current status on GitHub at <a href="https://github.com/christopher-besch/maki">christopher-besch/maki</a>.
Maki&#x27;s version as of this article&#x27;s writing can be accessed <a href="https://github.com/christopher-besch/maki/tree/30f3d5a358e1b89803a534c666318b14138a6756">here</a>.
Feel free to leave a star ^^</p>
<h2 id="directory-overview"><a aria-hidden="true" tabindex="-1" class="markdown_heading_a" href="#directory-overview"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Directory Overview</h2>
<pre><code>.
├── maki
│   ├── src
│   │   └── maki.cpp
│   └── CMakeLists.txt
├── maki_core
│   ├── include
│   │   └── maki.h
│   ├── res
│   │   └── shaders
│   │       ├── cuboid_frag.glsl
│   │       ├── cuboid_vert.glsl
│   │       ├── simple_fragment.glsl
│   │       └── simple_vertex.glsl
│   ├── src
│   │   ├── atom
│   │   │   ├── atoms
│   │   │   │   ├── cuboid_atom.cpp
│   │   │   │   ├── cuboid_atom.h
│   │   │   │   ├── quadrilateral_atom.cpp
│   │   │   │   └── quadrilateral_atom.h
│   │   │   ├── renderers
│   │   │   │   ├── batch_renderer.cpp
│   │   │   │   ├── batch_renderer.h
│   │   │   │   ├── cuboid_renderer.cpp
│   │   │   │   ├── cuboid_renderer.h
│   │   │   │   ├── quadrilateral_renderer.cpp
│   │   │   │   └── quadrilateral_renderer.h
│   │   │   ├── atom_chain.h
│   │   │   ├── atom_diff_frame.h
│   │   │   ├── atom_diff.h
│   │   │   ├── atom_diff_lifetime.h
│   │   │   ├── atom_dispenser.cpp
│   │   │   ├── atom_dispenser.h
│   │   │   ├── atom.h
│   │   │   └── atom_renderer.h
│   │   ├── core
│   │   │   ├── definitions.h
│   │   │   ├── log.cpp
│   │   │   ├── log.h
│   │   │   ├── thread_safety.cpp
│   │   │   └── thread_safety.h
│   │   ├── driver
│   │   │   ├── camera_driver.cpp
│   │   │   ├── camera_driver.h
│   │   │   ├── interface.h
│   │   │   ├── render_driver_control.cpp
│   │   │   ├── render_driver.h
│   │   │   └── render_driver_render.cpp
│   │   ├── platform
│   │   │   ├── glfw
│   │   │   │   └── glfw_window.cpp
│   │   │   ├── enums.h
│   │   │   ├── event.h
│   │   │   ├── window.cpp
│   │   │   └── window.h
│   │   ├── renderer
│   │   │   ├── opengl
│   │   │   │   ├── opengl_buffer.cpp
│   │   │   │   ├── opengl_buffer.h
│   │   │   │   ├── opengl_renderer.cpp
│   │   │   │   ├── opengl_renderer.h
│   │   │   │   ├── opengl_shader.cpp
│   │   │   │   ├── opengl_shader.h
│   │   │   │   ├── opengl_stringifier.cpp
│   │   │   │   ├── opengl_stringifier.h
│   │   │   │   ├── opengl_types.h
│   │   │   │   ├── opengl_vertex_array.cpp
│   │   │   │   └── opengl_vertex_array.h
│   │   │   ├── buffer.cpp
│   │   │   ├── buffer.h
│   │   │   ├── camera.cpp
│   │   │   ├── camera.h
│   │   │   ├── renderer.cpp
│   │   │   ├── renderer.h
│   │   │   ├── shader.cpp
│   │   │   ├── shader.h
│   │   │   ├── types.h
│   │   │   ├── vertex_array.cpp
│   │   │   └── vertex_array.h
│   │   ├── pch.cpp
│   │   └── pch.h
│   └── CMakeLists.txt
├── stub
│   ├── src
│   │   └── main.cpp
│   └── CMakeLists.txt
└── CMakeLists.txt
</code></pre>
<p>Created with</p>
<pre><code class="language-bash">tree --dirsfirst <span class="pl-c1">.</span> -I <span class="pl-s"><span class="pl-pds">&#x27;</span>vendor|build|pretty_bugs|block.txt|imgui.ini|LICENSE|maki.cpython-310-x86_64-linux-gnu.so|maki_showcase.ipynb|README.md<span class="pl-pds">&#x27;</span></span>
</code></pre><div class="markdown_spacer"></div></div></div><div class="title_in_text"><h1>Other Articles</h1><hr/></div><div class="cards_list"><a class="cards_list_card" href="/articles/ctemsoft"><picture class="image_picture"><img srcSet="/images/c5fde5a326c6a0b5e07c470ffda1eb59_400_200.webp 400w,/images/c5fde5a326c6a0b5e07c470ffda1eb59_800_400.webp 800w,/images/c5fde5a326c6a0b5e07c470ffda1eb59_1200_600.webp 1200w,/images/c5fde5a326c6a0b5e07c470ffda1eb59_1280_640.webp 1280w" width="400" height="200" style="background-image:radial-gradient(67% 67% at 25% 25%, #e2e2e2, transparent),radial-gradient(67% 67% at 50% 25%, #e1e1e1, transparent),radial-gradient(67% 67% at 75% 25%, #e3e3e3, transparent),radial-gradient(67% 67% at 25% 50%, #e4e4e4, transparent),radial-gradient(67% 67% at 50% 50%, #d7d7d7, transparent),radial-gradient(67% 67% at 75% 50%, #c0c0c0, transparent),radial-gradient(67% 67% at 25% 75%, #f9f9f9, transparent),radial-gradient(67% 67% at 50% 75%, #d9d9d9, transparent),radial-gradient(67% 67% at 75% 75%, #c1c1c1, transparent),linear-gradient(#dddddd);background-position:0 0, 0 100%;background-size:100% 100%;background-repeat:no-repeat"/></picture><h1>Docker: Breathing Life into Decades old Fortran</h1><h2>Sunday, 6th April, 2025</h2><hr/><p> Bringing decades old Fortran code to life with Docker and animating it with Python.
Now you get to see Fig.3.5. from &quot;Introduction to Conventional Transmission Electron Microscopy&quot; by Prof. Marc De Graef at 30 frames a second. </p></a><a class="cards_list_card" href="/articles/open_source"><picture class="image_picture"><img srcSet="/images/e5fdc90ab34ba9a541ab0d11b75e02de_400_200.webp 400w,/images/e5fdc90ab34ba9a541ab0d11b75e02de_800_400.webp 800w,/images/e5fdc90ab34ba9a541ab0d11b75e02de_1200_600.webp 1200w,/images/e5fdc90ab34ba9a541ab0d11b75e02de_1280_640.webp 1280w" width="400" height="200" style="background-image:radial-gradient(67% 67% at 25% 25%, #8e8784, transparent),radial-gradient(67% 67% at 50% 25%, #a69689, transparent),radial-gradient(67% 67% at 75% 25%, #bca38d, transparent),radial-gradient(67% 67% at 25% 50%, #695e66, transparent),radial-gradient(67% 67% at 50% 50%, #7a6368, transparent),radial-gradient(67% 67% at 75% 50%, #836168, transparent),radial-gradient(67% 67% at 25% 75%, #454d59, transparent),radial-gradient(67% 67% at 50% 75%, #5b525c, transparent),radial-gradient(67% 67% at 75% 75%, #7d585f, transparent),linear-gradient(#7f6f6f);background-position:0 0, 0 100%;background-size:100% 100%;background-repeat:no-repeat"/></picture><h1>Why I love Open-Source</h1><h2>Saturday, 11th October, 2025</h2><hr/><p> We all live in a world of immensely complex technology. The concept of Open-Source might seem radical at first but it&#x27;s indispensable in our world. Regardless if you are a user, developer or simply interested in a healthy society, you benefit from Open-Source and we should fight for every bit of it. Open-Source is a quality mark, a form of democracy and ownership, capitalism at its best and thus the response to this world, a world in which software exists. This article gets to that conclusion without requiring any prior technical knowledge. </p></a><a class="cards_list_card" href="/articles/github_pages_hack"><picture class="image_picture"><img srcSet="/images/2429205e42d7ecf6646d20aea86a90ce_400_200.webp 400w,/images/2429205e42d7ecf6646d20aea86a90ce_800_400.webp 800w,/images/2429205e42d7ecf6646d20aea86a90ce_1200_600.webp 1200w,/images/2429205e42d7ecf6646d20aea86a90ce_1280_640.webp 1280w" width="400" height="200" style="background-image:radial-gradient(67% 67% at 25% 25%, #e6e8ed, transparent),radial-gradient(67% 67% at 50% 25%, #f5f5f7, transparent),radial-gradient(67% 67% at 75% 25%, #f8f8f8, transparent),radial-gradient(67% 67% at 25% 50%, #eef2f2, transparent),radial-gradient(67% 67% at 50% 50%, #f8f9f9, transparent),radial-gradient(67% 67% at 75% 50%, #fbfafa, transparent),radial-gradient(67% 67% at 25% 75%, #edf0f1, transparent),radial-gradient(67% 67% at 50% 75%, #f7f7f7, transparent),radial-gradient(67% 67% at 75% 75%, #f6f8f9, transparent),linear-gradient(#f4f5f6);background-position:0 0, 0 100%;background-size:100% 100%;background-repeat:no-repeat"/></picture><h1>How my GitHub Pages got Hacked</h1><h2>Saturday, 18th October, 2025</h2><hr/><p> A DNS forward is an expression of trust. GitHub broke my trust and someone else received control over my domain. </p></a><a class="cards_list_card" href="/articles/svg_fonts_with_sed"><picture class="image_picture"><img srcSet="/images/f59a7f43e2f2a641d46f9fd994b5589c_400_200.webp 400w,/images/f59a7f43e2f2a641d46f9fd994b5589c_800_400.webp 800w,/images/f59a7f43e2f2a641d46f9fd994b5589c_1200_600.webp 1200w,/images/f59a7f43e2f2a641d46f9fd994b5589c_1280_640.webp 1280w" width="400" height="200" style="background-image:radial-gradient(67% 67% at 25% 25%, #f5f6f6, transparent),radial-gradient(67% 67% at 50% 25%, #d6dbdf, transparent),radial-gradient(67% 67% at 75% 25%, #dadfe4, transparent),radial-gradient(67% 67% at 25% 50%, #b6b8ae, transparent),radial-gradient(67% 67% at 50% 50%, #614349, transparent),radial-gradient(67% 67% at 75% 50%, #604c4d, transparent),radial-gradient(67% 67% at 25% 75%, #d3d6c9, transparent),radial-gradient(67% 67% at 50% 75%, #bca298, transparent),radial-gradient(67% 67% at 75% 75%, #8b756c, transparent),linear-gradient(#b4aca9);background-position:0 0, 0 100%;background-size:100% 100%;background-repeat:no-repeat"/></picture><h1>Inject Fonts into Web SVGs with sed</h1><h2>Monday, 10th February, 2025</h2><hr/><p> Add font-loading CSS to SVGs with a sed script. </p></a></div><a href="/articles" class="button">Furthermore Articles</a></div></div><div class="layout_footer"><a href="/about">Contact</a><a href="/rss.xml">RSS</a><a href="/articles/privacy">Privacy</a><div>© 2025 | All rights reserved</div></div></body></html>